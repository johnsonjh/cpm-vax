GAS LISTING nv32forth.s 			page 1


   1              		.text
   2              	#####
   3              	#
   4              	# __start
   5              	#
   6              	#	CP/M enters the program here. We are passed a single
   7              	#	parameter, the address of the base page. The first longword of
   8              	#	the base page contains a pointer to the BDOS, which we need
   9              	#	to squirrel away so we can call it.
  10              	#
  11              	#####
  12              	
  13              	__start:
  14 0000 FE0F     		.word 0x0ffe		# entry mask
  15 0002 D0AC0450 		movl 4(ap),r0
  16 0006 D050AF10 		movl r0,__base_page
  17 000a D060AF08 		movl (r0),__bdos_pointer
  18 000e D05EAF0C 		movl sp,__initial_sp
  19 0012 17CF9F1D 		jmp Forth$$Begin
  20              	
  21              	__bdos_pointer:
  22 0016 00000000 		.long 0
  23              	__base_page:
  24 001a 00000000 		.long 0
  25              	__initial_sp:
  26 001e 00000000 		.long 0
  27              	
  28              	####
  29              	#
  30              	# ConIn
  31              	#
  32              	#	Receives a character from the console, returning it in R0.
  33              	#
  34              	####
  35              	
  36              	__ConIn_Args:
  37 0022 02000000 		.long 2			# Two parameters
  38 0026 06000000 		.long 6			# Direct Console I/O
  39 002a FF000000 		.long 0xff		# Read a character
  40              	
  41 002e D0AFE550 	ConIn:	movl __bdos_pointer,r0
  42 0032 FAAFED60 		callg __ConIn_Args,(r0)
  43 0036 05       		rsb
  44              	
  45              	####
  46              	#
  47              	# ConSt
  48              	#
  49              	#	Polls the console to see if a character is available.
  50              	#
  51              	###
  52              	
  53              	__ConSt_Args:
  54 0037 02000000 		.long 2			# Two parameters
  55 003b 06000000 		.long 6			# Direct Console I/O
  56 003f FE000000 		.long 0xfe		# Check status
  57              	
GAS LISTING nv32forth.s 			page 2


  58 0043 D0AFD050 	ConSt:	movl __bdos_pointer,r0
  59 0047 FAAFED60 		callg __ConSt_Args,(r0)
  60 004b 05       		rsb
  61              	
  62              	####
  63              	#
  64              	# ConOut
  65              	#
  66              	#	Display the character on R0 on the console.
  67              	#
  68              	####
  69              	
  70              	__ConOut_Args:
  71 004c 02000000 		.long 2			# Two parameters
  72 0050 06000000 		.long 6			# Direct Console I/O
  73              	__ConOut_Char:
  74 0054 00000000 		.long 0			# The character
  75              	
  76              	ConOut:
  77 0058 D050AFF8 		movl r0,__ConOut_Char
  78 005c D0AFB750 		movl __bdos_pointer,r0
  79 0060 FAAFE960 		callg __ConOut_Args,(r0)
  80 0064 05       		rsb
  81              	
  82              	 #****************************************************************************
  83              	 #
  84              	 #	Position-independent 32-bit VAX Forth small enough to fit in the
  85              	 #	primary cache of NV5.
  86              	 #
  87              	 #	Modified for use in a downline-boot diagnostic environment. Offsets
  88              	 #	are now 32 bits, allowing 4MB to be ALLOTted for TURBOchannel
  89              	 #	DMA skidpad.
  90              	 #
  91              	 #	Although the data manipulated by this Forth is 32-bits, 16-bit
  92              	 #	relative offsets are stored in compiled words. This is to make it
  93              	 #	1) position-independent and 2) small enough to fit in NV5's PCache.
  94              	 #	Since the target execution environment is NV5's PCache, limiting
  95              	 #	code size to 64KB using the 16-bit offsets is not a problem.
  96              	 #
  97              	 #	This forth started out as port of Allan Pratt's C-Forth, which is
  98              	 #	a port of FigFORTH to a portable C for migration to Un*x boxes.
  99              	 #	Mr. Pratt dropped some features he couldn't figure out how to implement
 100              	 #	(such as DOES> and vocabularies), and I don't understand them (yet);
 101              	 #	they remain dropped. The vocabulary is largely FigFORTH.
 102              	 #
 103              	 #	I've also dropped the "user variable" concept because I don't
 104              	 #	understand it. I believe it exists mainly to support FORTH multitasking,
 105              	 #	which I don't plan on ever using.
 106              	 #
 107              	 # revisions:
 108              	 #
 109              	 #	2005-03-28 rli: Began translation to gas.
 110              	 #
 111              	 #*****************************************************************************
 112              	
 113              	 #	Macro to generate a string consisting of ASCII characters with the
 114              	 #	last bit set.
GAS LISTING nv32forth.s 			page 3


 115              	
 116              		.macro string value
 117              		.byte 1f-0f
 118              	0:
 119              		.ascii "\value"
 120              	1:
 121              		.endm
 122              	
 123              	 #	Macro to generate the header for a word. A header looks like this:
 124              	 #
 125              	 #	+--------+
 126              	 #	|1IS     | Length of name. S = 0 to allow name to be found
 127              	 #	+--------+ \               I = 1 for immediate word
 128              	 #	|0       |  |
 129              	 #	/\/\/\/\/\  |
 130              	 #	/\/\/\/\/\   > Characters in name
 131              	 #	|0       |  |
 132              	 #	+--------+ /
 133              	 #	|        |     Offset to previous word's name
 134              	 #	|        |
 135              	 #	+--------+
 136              	 #	|        |     Code Field Address
 137              	 #	|        |
 138              	 #	+--------+
 139              	 #	|        |     Parameter Field Address
 140              	 #	/\/\/\/\/\
 141              	 #	/\/\/\/\/\
 142              	 #	|        |
 143              	 #	+--------+
 144              	 #
 145              	 #	The code field address is the address of machine code that is
 146              	 #	executed when the word is referenced. For Forth code, this
 147              	 #	machine code pushes the IP on the stack and begins interpreting
 148              	 #	the parameter field as forth words.
 149              	 #
 150              	 #	A reference to a forth word is two levels away from machine code.
 151              	 #	The first level is a reference to the CFA of the word. The second
 152              	 #	level is the machine code that knows how to "do" the word. The
 153              	 #	forth interpreter must relocate at each level of indirection to
 154              	 #	make a PIC implementation.
 155              	 #
 156              	 #	This macro also has to handle the special case of a null Codename
 157              	 #	for the null word.
 158              	
 159              	Immediate = 0x40
 160              	
 161              	###
 162              	#
 163              	#	Because gas sucks so bad, we have to tell it the name of the
 164              	#	previous word so we can build the link field. A real assembler
 165              	#	allows us to keep a symbol updated as we build the links, but
 166              	#	gas fills all the links in using the final value of the symbol.
 167              	#	ARGH!
 168              	#
 169              	###
 170              		.macro header_nfalink previousname,suffix
 171              		.long \previousname\suffix - .
GAS LISTING nv32forth.s 			page 4


 172              		.endm
 173              	
 174              		.macro header_label name,suffix
 175              	\name\suffix:
 176              		.endm
 177              	
 178              		.macro header_pfaoffset name,suffix
 179              	\name\suffix = .+4
 180              		.endm
 181              	
 182              	 #	Macro for putting forth words together
 183              	
 184              		.macro offset label
 185              		.long \label-.
 186              		.endm
 187              	
 188              	###
 189              	#
 190              	#	Generate a special header for the null word, which is immediate.
 191              	#	Since the list of words has to start somewhere and gas sucks so
 192              	#	much that it can't keep track of that for us, we now require the
 193              	#	null word to be the first word in the dictionary.
 194              	#
 195              	###
 196              	
 197              		.macro null_header
 198              		.equ header_temp,.
 199              		header_label "null","_nfa"
 200              		.byte 1+0x80+0x20+0x40
 201              		.byte 0
 202              		header_label "null","_lfa"
 203              		.long 0
 204              	null:
 205              		offset DoCol
 206              		.endm
 207              	
 208              		.macro header codename, username, previousname, flags=0
 209              		header_label "\codename","_nfa"
 210              		.byte (1f-0f)+\flags+0x80+0x20
 211              	0:
 212              		.ascii "\username"
 213              	1:
 214              		header_label "\codename","_lfa"
 215              		header_nfalink "\previousname","_nfa"
 216              	\codename:
 217              		header_pfaoffset "\codename","_pfa"
 218              		.endm
 219              	
 220              	 #	Macro to generate a variable. It's initialized to zero.
 221              	
 222              		.macro variable name, username, previousname
 223              		Header "\name", "\username", "\previousname"
 224              		offset DoVar
 225              		.long 0
 226              		.endm
 227              	
 228              	 #	Macro to generate a constant.
GAS LISTING nv32forth.s 			page 5


 229              	
 230              		.macro constant name, username, previousname, value
 231              		header "\name","\username","\previousname"
 232              		offset DoCon
 233              		.long \value
 234              		.endm
 235              	
 236              	 #	Macro to generate a forth word
 237              	
 238              		.macro colon name, username, previousname, immediate=0
 239              		header "\name","\username","\previousname",\immediate
 240              		offset DoCol
 241              		.endm
 242              	
 243              	 #	Macro to generate a machine code word that can be referenced as
 244              	 #	if it were a forth word; i.e., one that shows up in the dictionary.
 245              	 #	For these words, the address of the machine code that knows how to
 246              	 #	"do" the word is the address of the PFA.
 247              	
 248              		.macro code name, username, previousname, immediate=0
 249              		header "\name","\username","\previousname",\immediate
 250              		.long 4
 251              		.endm
 252              	
 253              	 #	Macro to compile a literal into a forth code word
 254              	 #
 255              	 #	If the literal fits into a single byte, ZBLIT is used instead of
 256              	 #	LIT; ZBLIT knows how to zero-extend bytes into a longword.
 257              	 #
 258              	 #	Unfortunately, LITERAL isn't smart enough to know about ZBLIT; in
 259              	 #	other words, the base word set can make use of this optimization,
 260              	 #	but it isn't available for any words you type in.
 261              	
 262              		.macro literal, value
 263              	 #.if value & ~255
 264              		offset LIT
 265              		.long \value
 266              	 #.else
 267              	 #	offset ZBLIT
 268              	 #	.byte \value
 269              	 #.endc
 270              		.endm
 271              	
 272              	 #	The initialization code is responsible for providing us with a
 273              	 #	return stack. I did this mainly so I could debug the sucker under
 274              	 #	VMS without running into problems with the tiny stack I want to
 275              	 #	use in NV5's PCache (one page of stack just isn't enough to do
 276              	 #	a QIO).
 277              	
 278              	 #	Space for the math stack
 279              	
 280 0065 010101   		.align 2
 281 0068 00000000 		.space 512,0
 281      00000000 
 281      00000000 
 281      00000000 
 281      00000000 
GAS LISTING nv32forth.s 			page 6


 282              	MathSpace:
 283              	
 284              	 #	Space for terminal input; when you type something at the console, it
 285              	 #	goes here.
 286              	
 287              	TibBuffer:			# For BDOS function 10
 288 0268 4F       		.byte 79
 289 0269 00       		.byte 0
 290              	TibSpace:
 291 026a 00000000 		.space 79,0
 291      00000000 
 291      00000000 
 291      00000000 
 291      00000000 
 292              	TibSpaceEnd:
 293              	
 294              	 #	Space for building formatted numeric output. This is much larger
 295              	 #	than is needed for formatted numeric output, but the space may
 296              	 #	come in handy for other things.
 297              	
 298 02b9 00000000 		.space 79,0
 298      00000000 
 298      00000000 
 298      00000000 
 298      00000000 
 299              	PadSpaceEnd:
 300              	
 301              	 #	Register Usage:
 302              	 #
 303              	 #	R0 -
 304              	 #	R1 -
 305              	 #	R2 -
 306              	 #	R3 -
 307              	 #	R4 -
 308              	 #	R5 -
 309              	 #	R6 - 
 310              	 #	R7 - math stack pointer
 311              	 #	R8 -
 312              	 #	R9 -  W, may be munched by CODE words
 313              	 #	R10 - IP
 314              	 #	R11 - Contains the address of Next so words can exit by JMP (R11),
 315              	 #	      one byte shorter than BRW Next
 316              	 #	R12 - VAX AP
 317              	 #	R13 - VAX FP
 318              	 #	R14 - VAX SP, used for return stack
 319              	 #	R15 - VAX PC, of course
 320              	
 321              	Next:
 322              	
 323              	 #C	This is the big kabloona. What it does is load the value at mem[ip]
 324              	 #C	into w, increment ip, and invoke prim. number w. This implies that
 325              	 #C	mem[ip] is the CFA of a word. What's in the CF of a word is the
 326              	 #C	number of the primitive which should be executed. For a word written
 327              	 #C	in FORTH, that primitive is "docol", which pushes ip to the return
 328              	 #C	stack, then uses w+2 (the PFA of the word) as the new ip. See 
 329              	 #C	"interp.doc" for more
 330              	
GAS LISTING nv32forth.s 			page 7


 331              	 #	What I'm doing differently is using word offsets in the CFA to the
 332              	 #	word to be executed. The assumption is that the code will be
 333              	 #	relatively small (this thing is meant to be able to execute in the
 334              	 #	8K cache inside the NV5), so I don't want to be lugging around
 335              	 #	32 bit addresses. Therefore, what I actually do is add the word
 336              	 #	at mem[ip] to ip to come up with the value to be loaded in w.
 337              	 #	Then, I can't simply jump to the address stored in mem[w]; I have
 338              	 #	relocate it before I can jump to it.
 339              	
 340 0308 C16A5A59 		addl3 (r10),r10,r9	# Fetch the offset to next forth word and
 341              					# convert it to an address
 342 030c C1695958 		addl3 (r9),r9,r8	# Fetch the offset to the machine code
 343              					# and convert it to an address
 344 0310 D58A     		tstl (r10)+		# ip++;
 345 0312 1768     		jmp (r8)		# Execute the word. The word finishes by
 346              					# jumping to Next
 347              	
 348              	 #	Here's the code that knows how to enter a Forth word
 349              	
 350              	DoCol:
 351 0314 D05A7E   		movl r10,-(sp)		# Save the return address
 352 0317 C104595A 		addl3 $4,r9,r10		# Start executing after docol
 353 031b 176B     		jmp (r11)
 354              	
 355              	 #	Here's the code that knows how to do a constant
 356              	
 357              	DoCon:
 358 031d D0A90477 		movl 4(r9),-(r7)
 359 0321 176B     		jmp (r11)
 360              	
 361              	 #	Here's the code that knows how to do a variable
 362              	
 363              	DoVar:
 364 0323 C1045977 		addl3 $4,r9,-(r7)
 365 0327 176B     		jmp (r11)
 366              	
 367              	 #	: {NUL}
 368              	 #	  R> DROP
 369              	 #	;*
 370              	 #
 371              	 #	This special word is found at the end of a command line. It is
 372              	 #	used to break out of the interpreter; at the end of the command
 373              	 #	line, the interpreter will search for the terminating null ending
 374              	 #	the line. It will find and execute this word. This word drops
 375              	 #	a return address from the return stack.
 376              	
 377 0329 E1000000 		null_header
 377      0000E5FF 
 377      FFFF
 378 0333 31010000 		offset FromR
 379 0337 CE010000 		offset DROP
 380 033b 0F100000 		offset SemiS
 381              	
 382              	 #	Branch: Add an offset to the IP.
 383              	 #
 384              	 #	The word following the the opcode is taken as a relative offset
 385              	 #	indicating the length of the branch. At entry, IP (R10) points to the
GAS LISTING nv32forth.s 			page 8


 386              	 #	word following the opcode, because Next incremented IP before executing
 387              	 #	the opcode. This word is fetched, sign-extended, and added to IP.
 388              	 #
 389              	 #	The branch code is also used by 0Branch.
 390              	
 391 033f A6425241 		code "BRANCH","BRANCH","null"
 391      4E4348E3 
 391      FFFFFF04 
 391      000000
 392              	ZBranch_Branch:
 393 034e C06A5A   		addl2 (r10),r10		# Update IP.
 394 0351 176B     		jmp (r11)
 395              	
 396              	 #	0Branch: Add an offset to IP if tos == 0
 397              	 #
 398              	 #	The word following the opcode is taken as a relative offset that
 399              	 #	is to be added to IP (R10) if the top element on the math stack
 400              	 #	is zero. In either case, the top element is removed from the
 401              	 #	math stack.
 402              	 #
 403              	 #	The code to skip the relative offset if the condition is not
 404              	 #	met is used in several places.
 405              	
 406 0353 A7304252 		code "ZBranch","0BRANCH","BRANCH"
 406      414E4348 
 406      E4FFFFFF 
 406      04000000 
 407 0363 D587     		tstl (r7)+		# Is the TOS zero?
 408 0365 13E7     		beql ZBranch_Branch	# If so, go
 409              	ZBranch_Skip:
 410 0367 D58A     		tstl (r10)+		# Skip the offset
 411 0369 176B     		jmp (r11)		# Next word
 412              	
 413              	 #	(loop): -- loop control
 414              	 #
 415              	 #	Assumes the return stack contains:
 416              	 #	 (sp) = index
 417              	 #	4(sp) = limit
 418              	 #
 419              	 #	This word does the end of a do loop; it updates the index and
 420              	 #	compares it to the limit to see if the loop should terminate. The
 421              	 #	index and limit are store on the return stack instead of the 
 422              	 #	math stack so that the math stack is available for mutilation.
 423              	 #
 424              	 #	The word following the opcode contains a relative index that will
 425              	 #	be added to the IP (R10) if the loop is to be continued; that is,
 426              	 #	the word following the opcode contains the relative offset to the
 427              	 #	top of the loop.
 428              	 #
 429              	 #	If the loop is not to be continued, the relative index is skipped.
 430              	 #
 431              	 #	The code decides to branch based on the index being less than the
 432              	 #	limit instead of deciding to skip if the index is the same as the
 433              	 #	limit to allow LEAVE to force the loop to exit by setting the index
 434              	 #	equal to the limit; since the code increments the index first,
 435              	 #	doing it the other way would cause an infinite loop if you decided
 436              	 #	to LEAVE.
GAS LISTING nv32forth.s 			page 9


 437              	 #
 438              	 #	The label PLoop_1 is used by (+LOOP) so that it doesn't have to
 439              	 #	duplicate the test for the end of the index.
 440              	
 441 036b A6284C4F 		code "PLoop","(LOOP)","ZBranch"
 441      4F5029E1 
 441      FFFFFF04 
 441      000000
 442 037a D66E     		incl (sp)		# Update index
 443              	PLoop_1:
 444 037c D16EAE04 		cmpl (sp),4(sp)		# Still need to loop?
 445 0380 1FCC     		blssu ZBranch_Branch	# If not, branch to top of loop
 446              	
 447 0382 D58E     		tstl (sp)+		# Discard index
 448 0384 D58E     		tstl (sp)+		# Discard limit
 449 0386 11DF     		brb ZBranch_Skip	# Skip offset AND do next word
 450              	
 451              	 #	(+loop): -- almost the same as (loop)
 452              	 #
 453              	 #	Assumes the return stack contains:
 454              	 #	 (sp) = index
 455              	 #	4(sp) = limit
 456              	 #
 457              	 #	This procedure adds the value on top of the math stack to the
 458              	 #	loop index and then does the rest of (LOOP); it's like (LOOP)
 459              	 #	except you can specify an increment other than one.
 460              	 #
 461              	 #	The increment is discarded from the math stack.
 462              	 #
 463              	 #	Like (LOOP), (+LOOP) is followed by a word containing the relative
 464              	 #	offset to the top of the loop.
 465              	
 466 0388 A7282B4C 		code "PPLoop","(+LOOP)","PLoop"
 466      4F4F5029 
 466      DBFFFFFF 
 466      04000000 
 467 0398 C0876E   		addl2 (r7)+,(sp)	# Add increment to index and discard increment.
 468 039b 11DF     		brb PLoop_1		# Check for loop completion
 469              	
 470              	 #	(do): limit init -- [pushed to rstack]
 471              	 #
 472              	 #	This procedure is the run-time initialization of a do loop; it takes
 473              	 #	the limit and initial value from the math stack and transfers them
 474              	 #	to the return stack to make the return stack look like what (loop)
 475              	 #	and (+loop) expect it to look like.
 476              	 #
 477              	 #	$$$
 478              	
 479 039d A428444F 		code "PDo","(DO)","PPLoop"
 479      29E6FFFF 
 479      FF040000 
 479      00
 480 03aa D0A7047E 		movl 4(r7),-(sp)	# push limit
 481 03ae D0877E   		movl (r7)+,-(sp)	# push init and discard
 482 03b1 D587     		tstl (r7)+		# Discard limit
 483 03b3 176B     		jmp (r11)
 484              	
GAS LISTING nv32forth.s 			page 10


 485              	 #	: DO
 486              	 #	  COMPILE (DO) HERE LIT 3
 487              	 #	;*
 488              	 #
 489              	 #	This word compiles the start of a do loop into the code. It adds
 490              	 #	the address of (DO) into the word and copies the address of the
 491              	 #	start of the code inside the DO loop onto the math stack. This
 492              	 #	will be used later by LOOP and +LOOP.
 493              	 #
 494              	 #	The 3 marks the stuff on the math stack as belonging to a DO loop.
 495              	
 496 03b5 E2444FE5 		colon "DO","DO","PDo",Immediate
 496      FFFFFF58 
 496      FFFFFF
 497 03c0 9C120000 		offset COMPILE		# Append (DO) to the current word
 498 03c4 E2FFFFFF 		offset PDo
 499 03c8 14080000 		offset HERE		# Remember address of top of loop
 500 03cc 77070000 		literal 3		# and that we're doing a DO loop
 500      03000000 
 501 03d4 760F0000 		offset SemiS
 502              	
 503              	 #	: LOOP
 504              	 #	  LIT 3 ?PAIRS COMPILE (LOOP) O,
 505              	 #	;*
 506              	 #
 507              	 #	This word compiles the end of a DO loop for the standard increment
 508              	 #	of one. If we're currently compiling a DO loop, it appends 
 509              	 #	(LOOP) followed by the offset to the top of the loop to current
 510              	 #	word.
 511              	 #
 512              	 #	$$$
 513              	
 514 03d8 E44C4F4F 		colon "LOOP","LOOP","DO",Immediate
 514      50D8FFFF 
 514      FF33FFFF 
 514      FF
 515 03e5 5E070000 		literal 3		# Complain if we're not doing a DO loop
 515      03000000 
 516 03ed 62150000 		offset QPairs
 517 03f1 6B120000 		offset COMPILE		# Append (LOOP) to the word
 518 03f5 81FFFFFF 		offset PLoop
 519 03f9 7C080000 		offset OComma		# and the offset to the top of the loop
 520 03fd 4D0F0000 		offset SemiS
 521              	
 522              	 #	: +LOOP
 523              	 #	  LIT 3 ?PAIRS COMPILE (+LOOP) O,
 524              	 #	;*
 525              	 #
 526              	 #	This word compiles the end of a DO loop when an increment other than
 527              	 #	one is needed. If we're currently compiling a DO loop, (+LOOP) is
 528              	 #	appended to the word followed by the offset to the top of the 
 529              	 #	loop.
 530              	 #
 531              	 #	$$$
 532              	
 533 0401 E52B4C4F 		colon "PlusLoop","+LOOP","LOOP",Immediate
 533      4F50D1FF 
GAS LISTING nv32forth.s 			page 11


 533      FFFF09FF 
 533      FFFF
 534 040f 34070000 		literal 3		# Complain if we're not doing a DO loop
 534      03000000 
 535 0417 38150000 		offset QPairs
 536 041b 41120000 		offset COMPILE		# Append (+LOOP) to the word
 537 041f 75FFFFFF 		offset PPLoop
 538 0423 52080000 		offset OComma		# and the offset to the top of the loop
 539 0427 230F0000 		offset SemiS
 540              	
 541              	 #	leave: set the index = the limit of a DO
 542              	 #
 543              	 #	Assumes:
 544              	 #	 (sp) = index
 545              	 #	4(sp) = limit
 546              	 #
 547              	 #	This procedure updates the return stack such that the next
 548              	 #	(LOOP) or (+LOOP) will cause the loop to exit. It does this by
 549              	 #	clearing the limit so that the index cannot be less than the
 550              	 #	limit next time it is checked ( (LOOP) and (+LOOP) use an
 551              	 #	unsigned comparison).
 552              	
 553 042b A54C4541 		code "LEAVE","LEAVE","PlusLoop"
 553      5645D0FF 
 553      FFFF0400 
 553      0000
 554 0439 D4AE04   		clrl 4(sp)		# Clear limit
 555 043c 176B     		jmp (r11)
 556              	
 557              	 #	I: Copy current do loop limit to math stack
 558              	 #
 559              	 #	This word is used by the innards of a DO loop to examine the
 560              	 #	index. Since the index is the top item of the return stack, the
 561              	 #	top of the return stack is pushed onto the math stack.
 562              	 #
 563              	 #	Since R is essentially a synonym for I, it enters at RI1.
 564              	
 565 043e A149EBFF 		code "I","I","LEAVE"
 565      FFFF0400 
 565      0000
 566 0448 D06E77   	RI1:	movl (sp),-(r7)		# Push a copy of top of return stack
 567 044b 176B     		jmp (r11)
 568              	
 569              	 #	>R: a -- Push onto return stack
 570              	 #
 571              	 #	This word pushes the item currently on the top of the math stack
 572              	 #	onto the return stack.
 573              	
 574 044d A23E52EE 		code "ToR",">R","I"
 574      FFFFFF04 
 574      000000
 575 0458 D0877E   		movl (r7)+,-(sp)
 576 045b 176B     		jmp (r11)
 577              	
 578              	 #	<R: -- a <pop from return stack>
 579              	 #
 580              	 #	This word pushes the item currently on top of the return stack
GAS LISTING nv32forth.s 			page 12


 581              	 #	onto the math stack.
 582              	
 583 045d A2523EED 		code "FromR","R>","ToR"
 583      FFFFFF04 
 583      000000
 584 0468 D08E77   		movl (sp)+,-(r7)
 585 046b 176B     		jmp (r11)
 586              	
 587              	
 588              	 #	R: Copy top of return stack to math stack
 589              	 #
 590              	 #	This word is used when you want to retrieve an item from the
 591              	 #	top of the return stack without modifying the return stack; the
 592              	 #	return stack is used as a convenient place to stash local variables.
 593              	 #
 594              	 #	Since this is essentially a synonym for I, it hops into the middle
 595              	 #	of the code for I.
 596              	
 597 046d A152EEFF 		code "R","R","FromR"
 597      FFFF0400 
 597      0000
 598 0477 11CF     		brb RI1			# See I
 599              	
 600              	 #	RP@: -- return stack pointer
 601              	 #
 602              	 #	This procedure returns the current value of the return stack pointer.
 603              	 #	Again, I'm not sure how useful this is since I'm not supporting 
 604              	 #	other things needed for FORTH multitasking.
 605              	
 606 0479 A3525040 		code "RPFetch","RP@","R"
 606      F0FFFFFF 
 606      04000000 
 607 0485 D05E77   		movl sp,-(r7)
 608 0488 176B     		jmp (r11)
 609              	
 610              	 #	RP!: --  <Initialize return stack pointer>
 611              	 #
 612              	 #	This procedure restores the return stack to its original value. 
 613              	 #	This is used when aborting.
 614              	 #
 615              	 #	I'm assuming the original caller of the FORTH system initialized
 616              	 #	the stack pointer. This lets me debug under VMS without needing
 617              	 #	a large array to handle stack requirements of (e.g.) $QIO; the
 618              	 #	VMS code can simply pass in the stack pointer it got from VMS.
 619              	 #	The I/O routines for embedded apps are responsible for allocating
 620              	 #	stack space and initializing the stack pointer before starting
 621              	 #	FORTH.
 622              	
 623 048a A3525021 		code "RPStore","RP!","RPFetch"
 623      EBFFFFFF 
 623      04000000 
 624 0496 D0CF84FB 		movl __initial_sp,sp
 624      5E
 625 049b 176B     		jmp (r11)
 626              	
 627              	 #	SWAP: a b -- b a
 628              	 #
GAS LISTING nv32forth.s 			page 13


 629              	 #	This procedure swaps the two items at the top of the math stack.
 630              	
 631 049d A4535741 		code "SWAP","SWAP","RPStore"
 631      50E8FFFF 
 631      FF040000 
 631      00
 632 04aa D08750   		movl (r7)+,r0		# ( a b -- a <b -> R0> )
 633 04ad D08751   		movl (r7)+,r1		# ( a -- <a -> R1> )
 634 04b0 D05077   		movl r0,-(r7)		# ( -- b )
 635 04b3 D05177   		movl r1,-(r7)		# ( -- b a )
 636 04b6 176B     		jmp (r11)
 637              	
 638              	 #	Rot: a b c -- b c a
 639              	 #
 640              	 #	This procedure shuffles the top three items on the math stack
 641              	 #	as indicated.
 642              	 #
 643              	 #	$$$
 644              	
 645 04b8 A3524F54 		colon "ROT","ROT","SWAP"
 645      E1FFFFFF 
 645      54FEFFFF 
 646 04c4 90FFFFFF 		offset ToR	# ( a b c -- a b )
 647 04c8 DEFFFFFF 		offset SWAP	#         -- b a )
 648 04cc 98FFFFFF 		offset FromR	#         -- b a c )
 649 04d0 D6FFFFFF 		offset SWAP	#         -- b c a )
 650 04d4 760E0000 		offset SemiS
 651              	
 652              	 #	over: a b -- a b a
 653              	 #
 654              	 #	This procedure duplicates the second item on the math stack,
 655              	 #	pushing a new copy on the top.
 656              	
 657 04d8 A44F5645 		code "OVER","OVER","ROT"
 657      52DBFFFF 
 657      FF040000 
 657      00
 658 04e5 D0A70477 		movl 4(r7),-(r7)
 659 04e9 176B     		jmp (r11)
 660              	
 661              	 #	dup: a - a a
 662              	 #
 663              	 #	This procudure duplicates the top item of the math stack.
 664              	
 665 04eb A3445550 		code "DUP","DUP","OVER"
 665      E9FFFFFF 
 665      04000000 
 666 04f7 D06777   		movl (r7),-(r7)
 667 04fa 176B     		jmp (r11)
 668              	
 669              	 #	DROP: a --
 670              	 #
 671              	 #	Forgets the item on top of the math stack.
 672              	
 673 04fc A444524F 		code "DROP","DROP","DUP"
 673      50EAFFFF 
 673      FF040000 
GAS LISTING nv32forth.s 			page 14


 673      00
 674 0509 D587     		tstl (r7)+
 675 050b 176B     		jmp (r11)
 676              	
 677              	
 678              	 #	2dup: a b -- a b a b
 679              	 #
 680              	 #	This procedure duplicates a 64-bit value on top of the math stack.
 681              	
 682 050d A4324455 		code "TwoDUP","2DUP","DROP"
 682      50EAFFFF 
 682      FF040000 
 682      00
 683 051a 7D6777   		movq (r7),-(r7)
 684 051d 176B     		jmp (r11)
 685              	
 686              	 #	SP@: -- math stack pointer
 687              	 #
 688              	 #	This procedure returns the current value of the math stack. I return
 689              	 #	the value before it's fetched; I'm not sure it's important. I'm
 690              	 #	also not sure what use it is since I'm not doing other stuff
 691              	 #	important to FORTH multitasking.
 692              	
 693 051f A3535040 		code "SPFetch","SP@","TwoDUP"
 693      EAFFFFFF 
 693      04000000 
 694 052b D05777   		movl r7,-(r7)		# Push a copy of the math stack pointer.
 695 052e 176B     		jmp (r11)
 696              	
 697              	 #	sp!: -- <math stack pointer is loaded with original value>
 698              	 #
 699              	 #	This procedure initializes the math stack pointer to its default
 700              	 #	value; i.e., the top of the space reserved for the math stack.
 701              	 #	This is used when aborting.
 702              	
 703 0530 A3535021 		code "SPStore","SP!","SPFetch"
 703      EBFFFFFF 
 703      04000000 
 704 053c DECF28FD 		moval MathSpace,r7
 704      57
 705 0541 176B     		jmp (r11)
 706              	
 707              	 #	: -DUP		( V -- V | V V <DUPLICATE IF V != 0 > )
 708              	 #	  DUP
 709              	 #	  0BRANCH DDUP1 ( SKIP TO END IF IT WAS ZERO )
 710              	 #	  DUP
 711              	 #	LABEL DDUP1
 712              	 #	;
 713              	 #
 714              	 #	This word duplicates the TOS if it is not zero. If the TOS is
 715              	 #	zero, it is not duplicated.
 716              	
 717 0543 A42D4455 		colon "MinusDup","-DUP","SPStore"
 717      50E8FFFF 
 717      FFC8FDFF 
 717      FF
 718 0550 A3FFFFFF 		offset DUP
GAS LISTING nv32forth.s 			page 15


 719 0554 0BFEFFFF 		offset ZBranch
 720 0558 08000000 		offset DDup1
 721 055c 97FFFFFF 		offset DUP
 722 0560 EA0D0000 	DDup1:	offset SemiS
 723              	
 724              	 #	: !CSP		( SAVE CSP AT USER VAR CSP )
 725              	 #	  SP@ CSP ! ;
 726              	 #
 727              	 #	This word stores a copy of the current math stack pointer in 
 728              	 #	the variable CSP. After compilation, the compiler checks CSP
 729              	 #	against the math stack pointer to see if it's managed to pull
 730              	 #	everything off the stack.
 731              	
 732 0564 A4214353 		colon "StoreCSP","!CSP","MinusDup"
 732      50DAFFFF 
 732      FFA7FDFF 
 732      FF
 733 0571 B6FFFFFF 		offset SPFetch
 734 0575 72170000 		offset CSP
 735 0579 AE040000 		offset Store
 736 057d CD0D0000 		offset SemiS
 737              	
 738              	 #	-: a b -- a-b
 739              	 #
 740              	 #	This procedure subtracts the top item of the math stack from the
 741              	 #	next item on the math stack, returning the difference.
 742              	
 743 0581 A12DE1FF 		code "Subtract","-","StoreCSP"
 743      FFFF0400 
 743      0000
 744 058b C28767   		subl2 (r7)+,(r7)	# Subtract top item and discard
 745 058e 176B     		jmp (r11)
 746              	
 747              	 #	<: a b -- a<b
 748              	 #
 749              	 #	This code pushes 1 if the second number on the math stack is
 750              	 #	less than the number on top of the math stack and 0 otherwise.
 751              	 #	This seems to me to be backwards, so I checked FigFORTH for the
 752              	 #	VAX, which gives this definition:
 753              	 #
 754              	 #	: < - 0< ;
 755              	 #
 756              	 #	which works out the same way; the 0< will push one only if the
 757              	 #	result of the subtraction is negative, which will only be the case
 758              	 #	if b>a.
 759              	 #
 760              	 #	Hmm. If I get desparate for space, I could use the FigFORTH version;
 761              	 #	looks like it's smaller.
 762              	 #
 763              	 #	$$$
 764              	
 765 0590 A13CEFFF 		colon "Less","<","Subtract"
 765      FFFF7EFD 
 765      FFFF
 766 059a EDFFFFFF 		offset Subtract
 767 059e 83000000 		offset ZLess
 768 05a2 A80D0000 		offset SemiS
GAS LISTING nv32forth.s 			page 16


 769              	
 770              	 #	AND: a b -- a&b
 771              	 #
 772              	 #	The top two words on the math stack are anded. Since we don't have
 773              	 #	an and instruction, we have to complement b and then BICL.
 774              	 #
 775              	 #	I don't want a BICL
 776              	 #	I just wanna ride my motorSICL
 777              	 #	And I don't wanna die
 778              	 #	I just wanna ride my motorcy
 779              	 #	cle				-- Apologies to Arlo Guthrie
 780              	
 781 05a6 A3414E44 		code "AND","AND","Less"
 781      E6FFFFFF 
 781      04000000 
 782 05b2 D26767   		mcoml (r7),(r7)		# Form one's complement of b
 783 05b5 CA8767   		bicl2 (r7)+,(r7)	# BICL it and discard b
 784 05b8 176B     		jmp (r11)
 785              	
 786              	 #	OR: a b -- a or b
 787              	 #
 788              	 #	The top two items on the math stack are ORed and the result stored
 789              	 #	on the math stack.
 790              	
 791 05ba A24F52E9 		code "OR","OR","AND"
 791      FFFFFF04 
 791      000000
 792 05c5 C88767   		bisl2 (r7)+,(r7)	# Do it and discard b
 793 05c8 176B     		jmp (r11)
 794              	
 795              	 #	XOR: a b -- a xor b
 796              	 #
 797              	 #	The top two items on the math stack are XORed and the result stored
 798              	 #	on the math stack.
 799              	
 800 05ca A3584F52 		code "XOR","XOR","OR"
 800      ECFFFFFF 
 800      04000000 
 801 05d6 CC8767   		xorl2 (r7)+,(r7)	# Do it and discard b
 802 05d9 176B     		jmp (r11)
 803              	
 804              	 #	+!: val addr -- <add val to mem[addr]>
 805              	 #
 806              	 #	This procedure adds the second value on the math stack to the
 807              	 #	address specified on top of the math stack.
 808              	
 809 05db A22B21EC 		code "PlusStore","+!","XOR"
 809      FFFFFF04 
 809      000000
 810 05e6 C0A70497 		addl2 4(r7),*(r7)+	# Add val to addr and discard addr
 811 05ea D587     		tstl (r7)+		# DROP val
 812 05ec 176B     		jmp (r11)
 813              	
 814              	 #	toggle: addr bits -- <xor mem[addr] with bits, store in mem[addr]>
 815              	 #
 816              	 #	This procedure toggles the bits specified on top of the math stack
 817              	 #	in the longword addressed by the second item on the math stack.
GAS LISTING nv32forth.s 			page 17


 818              	 #	Oddly, the ordering of operands in this operation is not the FORTH
 819              	 #	norm of making it difficult to do in a single instruction...
 820              	
 821 05ee A6544F47 		code "TOGGLE","TOGGLE","PlusStore"
 821      474C45E6 
 821      FFFFFF04 
 821      000000
 822 05fd CC8797   		xorl2 (r7)+,*(r7)+	# Toggle bits and discard bits and addr
 823 0600 176B     		jmp (r11)
 824              	
 825              	 #	0=: a -- (a==0)
 826              	 #
 827              	 #	Pushes a 1 on the stack if a is zero, and a zero otherwise.
 828              	 #
 829              	 #	The bits of code used here to push the one and zero are used
 830              	 #	by other comparisons.
 831              	 #
 832              	 #	$$$
 833              	
 834 0602 A2303DE9 		code "ZEq","0=","TOGGLE"
 834      FFFFFF04 
 834      000000
 835 060d D567     		tstl (r7)
 836 060f 1304     		beql Yes
 837              	
 838 0611 D467     	No:	clrl (r7)		# It's false. Push a zero.
 839 0613 176B     		jmp (r11)
 840              	
 841 0615 9A0167   	Yes:	movzbl $1,(r7)		# It's true. Push a one.
 842 0618 176B     		jmp (r11)
 843              	
 844              	 #	0< a -- (a < 0)
 845              	 #
 846              	 #	Pushes a 1 if a is negative, a 0 otherwise.
 847              	
 848 061a A2303CE5 		code "ZLess","0<","ZEq"
 848      FFFFFF04 
 848      000000
 849 0625 D567     		tstl (r7)
 850 0627 19EC     		blss Yes
 851 0629 11E6     		brb No
 852              	
 853              	 #	=: a b -- (a=b)
 854              	 #
 855              	 #	Pushes a one if a and b are equal, a zero otherwise.
 856              	 #
 857              	 #	$$$
 858              	
 859 062b A13DEDFF 		code "Equal","=","ZLess"
 859      FFFF0400 
 859      0000
 860 0635 D18767   		cmpl (r7)+,(r7)
 861 0638 13DB     		beql Yes
 862 063a 11D5     		brb No
 863              	
 864              	 #	!=: a b -- (a!=b)
 865              	 #
GAS LISTING nv32forth.s 			page 18


 866              	 #	Pushes a one if a and b are not equal, a zero otherwise.
 867              	 #
 868              	 #	$$$
 869              	
 870 063c A2213DEC 		code NotEq,"!=","Equal"
 870      FFFFFF04 
 870      000000
 871 0647 D18767   		cmpl (r7)+,(r7)
 872 064a 13C5     		beql No
 873 064c 11C7     		brb Yes
 874              	
 875              	 #	u<: a b -- (a<b, unsigned)
 876              	 #
 877              	 #	Pushes a one if a is less than b unsignedly.
 878              	 #
 879              	 #	$$$
 880              	
 881 064e A2553CEB 		code "ULess","U<","NotEq"
 881      FFFFFF04 
 881      000000
 882 0659 D1A70487 		cmpl 4(r7),(r7)+	# Compare and discard b
 883 065d 1FB6     		blssu Yes		# If A is less, push 1
 884 065f 11B0     		brb No			# Otherwise, push 0
 885              	
 886              	 #	: >	( CHEAP TRICK )  ( a b -- a>b )
 887              	 #	  SWAP < ;
 888              	
 889 0661 A13EEBFF 		colon "Greater",">","ULess"
 889      FFFFADFC 
 889      FFFF
 890 066b 3BFEFFFF 		offset SWAP
 891 066f 27FFFFFF 		offset Less
 892 0673 D70C0000 		offset SemiS
 893              	
 894              	 #	: <>	( NOT-EQUAL )
 895              	 #	  != ;
 896              	 #
 897              	 #	The C-Forth guy used C syntax for the machine code version of !=,
 898              	 #	probably to save himself lots-o'-headaches for his fingers trained
 899              	 #	on C. I'm not quite so attached, but I'm not gonna rip it out either.
 900              	
 901 0677 A23C3EE7 		colon "NotEqual","<>","Greater"
 901      FFFFFF96 
 901      FCFFFF
 902 0682 C1FFFFFF 		offset NotEq
 903 0686 C40C0000 		offset SemiS
 904              	
 905              	 #	+: a b -- a + b
 906              	 #
 907              	 #	Adds the numbers on top of the math stack.
 908              	
 909 068a A12BEBFF 		code "Plus","+","NotEqual"
 909      FFFF0400 
 909      0000
 910 0694 C08767   		addl2 (r7)+,(r7)
 911 0697 176B     		jmp (r11)
 912              	
GAS LISTING nv32forth.s 			page 19


 913              	 #	MINUS: a -- -a
 914              	 #
 915              	 #	Forms the two's complement of the number on top of the math stack.
 916              	
 917 0699 A54D494E 		code "MINUS","MINUS","Plus"
 917      5553EBFF 
 917      FFFF0400 
 917      0000
 918 06a7 CE6767   		mnegl (r7),(r7)
 919 06aa 176B     		jmp (r11)
 920              	
 921              	 #	NOT: a -- ~a
 922              	 #
 923              	 #	Forms the one's complement of the number on top of the math stack.
 924              	 #
 925              	 #	$$$
 926              	
 927 06ac A34E4F54 		code "NOT","NOT","MINUS"
 927      E9FFFFFF 
 927      04000000 
 928 06b8 D26767   		mcoml (r7),(r7)
 929 06bb 176B     		jmp (r11)
 930              	
 931              	 #	: 1+ 1 + ;	( val -- val+1 )
 932              	 #
 933              	 #	Shorthand word for incrementing top of stack.
 934              	
 935 06bd A2312BEC 		colon "OnePlus","1+","NOT"
 935      FFFFFF50 
 935      FCFFFF
 936 06c8 7C160000 		offset One		# Increment
 937 06cc C4FFFFFF 		offset Plus
 938 06d0 7A0C0000 		offset SemiS
 939              	
 940              	 #	: 2+ 2 + ;	( val -- val+2 )
 941              	 #
 942              	 #	Shorthand word for incrementing by two. Since I'm a 32-bit
 943              	 #	implementation, I should probably include 4+ and perhaps even
 944              	 #	8+, but I'm not gonna...
 945              	
 946 06d4 A2322BE6 		colon "TwoPlus","2+","OnePlus"
 946      FFFFFF39 
 946      FCFFFF
 947 06df 73160000 		offset Two
 948 06e3 ADFFFFFF 		offset Plus
 949 06e7 630C0000 		offset SemiS
 950              	
 951              	 #	: 1- 1 - ;	( val -- val-1 )
 952              	 #
 953              	 #	Shorthand to decrement top of stack
 954              	
 955 06eb A2312DE6 		colon "OneMinus","1-","TwoPlus"
 955      FFFFFF22 
 955      FCFFFF
 956 06f6 4E160000 		offset One
 957 06fa 8DFEFFFF 		offset Subtract
 958 06fe 4C0C0000 		offset SemiS
GAS LISTING nv32forth.s 			page 20


 959              	
 960              	 #	: +-		( a b -- c )
 961              	 #	  0<
 962              	 #	  0BRANCH PM1
 963              	 #	  MINUS
 964              	 #	LABEL PM1
 965              	 #	;
 966              	 #
 967              	 #	This procedure applies the sign of b to a, generating c. If b is
 968              	 #	positive, a is not changed. If b is negative, a is multiplied by
 969              	 #	-1.
 970              	
 971 0702 A22B2DE6 		colon "PlusMinus","+-","OneMinus"
 971      FFFFFF0B 
 971      FCFFFF
 972 070d 14FFFFFF 		offset ZLess
 973 0711 4EFCFFFF 		offset ZBranch
 974 0715 08000000 		offset PM1
 975 0719 8AFFFFFF 		offset MINUS
 976 071d 2D0C0000 	PM1:	offset SemiS
 977              	
 978              	 #	: ABS		( a -- b )
 979              	 #	  DUP +-
 980              	 #	;
 981              	 #
 982              	 #	This word takes the absolute value of the top of stack.
 983              	
 984 0721 A3414253 		colon "ABS","ABS","PlusMinus"
 984      DDFFFFFF 
 984      EBFBFFFF 
 985 072d C6FDFFFF 		offset DUP
 986 0731 D8FFFFFF 		offset PlusMinus
 987 0735 150C0000 		offset SemiS
 988              	
 989              	 #	: MIN		( a b -- c )
 990              	 #	  2DUP >
 991              	 #	  0BRANCH MIN1
 992              	 #	  SWAP
 993              	 #	LABEL MIN1
 994              	 #	  DROP
 995              	 #	;
 996              	 #
 997              	 #	This word returns the smaller of the two items on top of the math
 998              	 #	stack.
 999              	
 1000 0739 A34D494E 		colon "MIN","MIN","ABS"
 1000      E4FFFFFF 
 1000      D3FBFFFF 
 1001 0745 D1FDFFFF 		offset TwoDUP
 1002 0749 1EFFFFFF 		offset Greater
 1003 074d 12FCFFFF 		offset ZBranch
 1004 0751 08000000 		offset Min1
 1005 0755 51FDFFFF 		offset SWAP
 1006 0759 ACFDFFFF 	Min1:	offset DROP
 1007 075d ED0B0000 		offset SemiS
 1008              	
 1009              	 #	: MAX		( a b -- c )
GAS LISTING nv32forth.s 			page 21


 1010              	 #	  2DUP <
 1011              	 #	  0BRANCH MAX1
 1012              	 #	  SWAP
 1013              	 #	LABEL MAX1
 1014              	 #	  DROP
 1015              	 #	;
 1016              	 #
 1017              	 #	This word returns the larger of the two items on top of the math stack.
 1018              	 #
 1019              	 #	$$$
 1020              	
 1021 0761 A34D4158 		colon "MAX","MAX","MIN"
 1021      D4FFFFFF 
 1021      ABFBFFFF 
 1022 076d A9FDFFFF 		offset TwoDUP
 1023 0771 25FEFFFF 		offset Less
 1024 0775 EAFBFFFF 		offset ZBranch
 1025 0779 08000000 		offset Max1
 1026 077d 29FDFFFF 		offset SWAP
 1027 0781 84FDFFFF 	Max1:	offset DROP
 1028 0785 C50B0000 		offset SemiS
 1029              	
 1030              	 #	: *		( a b -- c )
 1031              	 #	  M* DROP
 1032              	 #	;
 1033              	 #
 1034              	 #	This word multiplies the two single-precision numbers on top of the
 1035              	 #	math stack to give a single-precision result.
 1036              	
 1037 0789 A12AD6FF 		colon "Star","*","MAX"
 1037      FFFF85FB 
 1037      FFFF
 1038 0793 A9010000 		offset MStar
 1039 0797 6EFDFFFF 		offset DROP
 1040 079b AF0B0000 		offset SemiS
 1041              	
 1042              	 #	: /MOD		( a b -- rem quo )
 1043              	 #	  >R S->D R> M/
 1044              	 #	;
 1045              	 #
 1046              	 #	This word divides the single-precision number a by the single-
 1047              	 #	precision number b and returns both the remainder and the quotient.
 1048              	
 1049 079f A42F4D4F 		colon "SlashMod","/MOD","Star"
 1049      44E5FFFF 
 1049      FF6CFBFF 
 1049      FF
 1050 07ac A8FCFFFF 		offset ToR
 1051 07b0 76010000 		offset SignExtend
 1052 07b4 B0FCFFFF 		offset FromR
 1053 07b8 B7010000 		offset MSlash
 1054 07bc 8E0B0000 		offset SemiS
 1055              	
 1056              	 #	: /		( a b -- c )
 1057              	 #	  /MOD SWAP DROP
 1058              	 #	;
 1059              	 #
GAS LISTING nv32forth.s 			page 22


 1060              	 #	This word divides a by b, returning only the quotient as c.
 1061              	
 1062 07c0 A12FDDFF 		colon "Slash","/","SlashMod"
 1062      FFFF4EFB 
 1062      FFFF
 1063 07ca DEFFFFFF 		offset SlashMod
 1064 07ce D8FCFFFF 		offset SWAP
 1065 07d2 33FDFFFF 		offset DROP
 1066 07d6 740B0000 		offset SemiS
 1067              	
 1068              	 #	: MOD		( a b -- c )
 1069              	 #	  /MOD DROP
 1070              	 #	;
 1071              	 #
 1072              	 #	This word divides a by b, returning only the remainder as c.
 1073              	
 1074 07da A34D4F44 		colon "MOD","MOD","Slash"
 1074      E2FFFFFF 
 1074      32FBFFFF 
 1075 07e6 C2FFFFFF 		offset SlashMod
 1076 07ea 1BFDFFFF 		offset DROP
 1077 07ee 5C0B0000 		offset SemiS
 1078              	
 1079              	 #	: */MOD		( a b c -- rem quo )
 1080              	 #	  >R M* R> M/
 1081              	 #	;
 1082              	 #
 1083              	 #	This word multiplies a by b and then divides the result by c, 
 1084              	 #	returning both the remainder and the quotient of the division.
 1085              	 #	The intermediate result is a double-precision number for that
 1086              	 #	extra precise precision.
 1087              	
 1088 07f2 A52A2F4D 		colon "StarSlashMod","*/MOD","MOD"
 1088      4F44E2FF 
 1088      FFFF18FB 
 1088      FFFF
 1089 0800 54FCFFFF 		offset ToR
 1090 0804 38010000 		offset MStar
 1091 0808 5CFCFFFF 		offset FromR
 1092 080c 63010000 		offset MSlash
 1093 0810 3A0B0000 		offset SemiS
 1094              	
 1095              	 #	: */			( a b c -- quo )
 1096              	 #	  */MOD
 1097              	 #	  SWAP DROP
 1098              	 #	;
 1099              	 #
 1100              	 #	This word multiples a and b and then divides that result by c,
 1101              	 #	returning only the quotient. The intermediate result is 
 1102              	 #	double-precision.
 1103              	
 1104 0814 A22A2FDB 		colon "StarSlash","*/","StarSlashMod"
 1104      FFFFFFF9 
 1104      FAFFFF
 1105 081f DDFFFFFF 		offset StarSlashMod
 1106 0823 83FCFFFF 		offset SWAP
 1107 0827 DEFCFFFF 		offset DROP
GAS LISTING nv32forth.s 			page 23


 1108 082b 1F0B0000 		offset SemiS
 1109              	
 1110              	 #	: <<	( val count -- val<<count )
 1111              	 #
 1112              	 #	Shifts the value left by the specified count
 1113              	
 1114 082f A23C3CE2 		code "ShiftLeft","<<","StarSlash"
 1114      FFFFFF04 
 1114      000000
 1115 083a D08750   		movl (r7)+,r0		# Get count and discard
 1116 083d 78506767 		ashl r0,(r7),(r7)	# Do the shift
 1117 0841 176B     		jmp (r11)
 1118              	
 1119              	 #	: >>	( val count -- val>>count )
 1120              	 #
 1121              	 #	Shifts the value right by the specified count
 1122              	
 1123 0843 A23E3EE9 		code "ShiftRight",">>","ShiftLeft"
 1123      FFFFFF04 
 1123      000000
 1124 084e CE8750   		mnegl (r7)+,r0		# Get count, make it a left shift count, discard
 1125 0851 78506767 		ashl r0,(r7),(r7)	# Do the shift
 1126 0855 176B     		jmp (r11)
 1127              	
 1128              	 #	D+: alo ahi blo bhi -- a+blo a+bhi <double add>
 1129              	 #
 1130              	 #	This procedure does a 64-bit add of the top two elements of the
 1131              	 #	math stack, returning a 64-bit result.
 1132              	
 1133 0857 A2442BE9 		code "DPlus","D+","ShiftRight"
 1133      FFFFFF04 
 1133      000000
 1134 0862 D08751   		movl (r7)+,r1		# Get bhi and discard
 1135 0865 D08750   		movl (r7)+,r0		# Get blo and discard
 1136 0868 C050A704 		addl2 r0,4(r7)		# Add blo to alo
 1137 086c D85167   		adwc r1,(r7)		# Add bhi and carry to ahi
 1138 086f 176B     		jmp (r11)
 1139              	
 1140              	 #	D-: alo ahi blo bhi -- a-blo a-bhi <double subtract>
 1141              	 #
 1142              	 #	This procedure subtracts the 64-bit number on top of the math stack
 1143              	 #	from the 64-bit number in the next position on the math stack. The
 1144              	 #	result is returned on the math stack.
 1145              	
 1146 0871 A2442DE3 		code "DSubtract","D-","DPlus"
 1146      FFFFFF04 
 1146      000000
 1147 087c D08751   		movl (r7)+,r1		# Get bhi and discard from math stack
 1148 087f D08750   		movl (r7)+,r0		# Get blo and discard from math stack
 1149 0882 C250A704 		subl2 r0,4(r7)		# Subtract low longword
 1150 0886 D95167   		sbwc r1,(r7)		# Subtract high longword and borrow
 1151 0889 176B     		jmp (r11)
 1152              	
 1153              	 #	DMINUS: alo ahi - -alo -ahi <double complement>
 1154              	 #
 1155              	 #	This procedure forms the two's complement of the 64-bit number on
 1156              	 #	top of the math stack. The result is stored on the math stack.
GAS LISTING nv32forth.s 			page 24


 1157              	 #	The two's complement is formed by subtracting the 64-bit number
 1158              	 #	from zero.
 1159              	
 1160 088b A6444D49 		code "DMINUS","DMINUS","DSubtract"
 1160      4E5553DF 
 1160      FFFFFF04 
 1160      000000
 1161 089a 7C50     		clrq r0			# Clear R0 and R1
 1162 089c C3A70450 		subl3 4(r7),r0,4(r7)	# Complement low word
 1162      A704
 1163 08a2 D90051   		sbwc $0,r1		# Propagate the borrow
 1164 08a5 C3675167 		subl3 (r7),r1,(r7)	# Complement high word
 1165 08a9 176B     		jmp (r11)
 1166              	
 1167              	 #	: D+-		( a.lo a.hi b -- c.lo c.hi )
 1168              	 #	  0<
 1169              	 #	  0BRANCH DPM1
 1170              	 #	  DMINUS
 1171              	 #	LABEL DPM1
 1172              	 #	;
 1173              	 #
 1174              	 #	This word applies the sign of b to the double-precision number a
 1175              	 #	to generate the double-precision number c. If b is positive, a
 1176              	 #	is unchanged. If b is negative, a is multiplied by -1.
 1177              	
 1178 08ab A3442B2D 		colon "DPlusMinus","D+-","DMINUS"
 1178      DCFFFFFF 
 1178      61FAFFFF 
 1179 08b7 6AFDFFFF 		offset ZLess
 1180 08bb A4FAFFFF 		offset ZBranch
 1181 08bf 08000000 		offset DPM1
 1182 08c3 D3FFFFFF 		offset DMINUS
 1183 08c7 830A0000 	DPM1:	offset SemiS
 1184              	
 1185              	 #	: DABS		( a.lo a.hi -- b.lo b.hi )
 1186              	 #	  DUP D+-
 1187              	 #	;
 1188              	 #
 1189              	 #	This word takes the absolute value of the double-precision number
 1190              	 #	on top of the math stack.
 1191              	
 1192 08cb A4444142 		colon "DABS","DABS","DPlusMinus"
 1192      53DBFFFF 
 1192      FF40FAFF 
 1192      FF
 1193 08d8 1BFCFFFF 		offset DUP
 1194 08dc D7FFFFFF 		offset DPlusMinus
 1195 08e0 6A0A0000 		offset SemiS
 1196              	
 1197              	 #	U*: a b -- a*b.lo a*b.hi
 1198              	 #
 1199              	 #	This is an unsigned double-length multiply. In this case,
 1200              	 #	double-length is 64 bits, but we won't be picky.
 1201              	
 1202 08e4 A2552AE4 		code "UStar","U*","DABS"
 1202      FFFFFF04 
 1202      000000
GAS LISTING nv32forth.s 			page 25


 1203 08ef 7A878700 		emul (r7)+,(r7)+,$0,r0	# Do it
 1203      50
 1204 08f4 D05077   		movl r0,-(r7)		# Push result
 1205 08f7 D05177   		movl r1,-(r7)
 1206 08fa 176B     		jmp (r11)
 1207              	
 1208              	 #	U/: num.lo num.hi denom -- rem quot
 1209              	 #
 1210              	 #	This is a generalized unsigned divide of a double-length number
 1211              	 #	by a single-length number. Other words use this routine to do
 1212              	 #	their work and then pick the results they want.
 1213              	
 1214 08fc A2552FE5 		code "USlash","U/","UStar"
 1214      FFFFFF04 
 1214      000000
 1215 0907 D08752   		movl (r7)+,r2		# Denominator
 1216 090a D08751   		movl (r7)+,r1		# high-order numerator
 1217 090d D08750   		movl (r7)+,r0		# low-order numerator
 1218 0910 7B525053 		ediv r2,r0,r3,r4	# Do it
 1218      54
 1219 0915 D05477   		movl r4,-(r7)		# Push remainder
 1220 0918 D05377   		movl r3,-(r7)		# Push quotient
 1221 091b 176B     		jmp (r11)
 1222              	
 1223              	 #	: S->D	( a -- a.lo a.hi )
 1224              	 #
 1225              	 #	This word sign-extends a single-precision number into a 
 1226              	 #	double-precision number.
 1227              	 #
 1228              	 #	$$$
 1229              	
 1230 091d A4532D3E 		code "SignExtend","S->D","USlash"
 1230      44DAFFFF 
 1230      FF040000 
 1230      00
 1231 092a D477     		clrl -(r7)		# Assume it's positive
 1232 092c D5A704   		tstl 4(r7)		# Are we right?
 1233 092f 1802     		bgeq S2D1		# If so, go
 1234 0931 D767     		decl (r7)		# If not, turn the 0 into a -1
 1235 0933 176B     	S2D1:	jmp (r11)
 1236              	
 1237              	 #	: M*		( a b -- c.lo c.hi )
 1238              	 #	  2DUP XOR >R ABS SWAP ABS U* R> D+-
 1239              	 #	;
 1240              	 #
 1241              	 #	This word multiplies the two numbers on top of the math stack to
 1242              	 #	give a double-precision result.
 1243              	
 1244 0935 A24D2AE5 		colon "MStar","M*","SignExtend"
 1244      FFFFFFD8 
 1244      F9FFFF
 1245 0940 D6FBFFFF 		offset TwoDUP
 1246 0944 8EFCFFFF 		offset XOR
 1247 0948 0CFBFFFF 		offset ToR
 1248 094c DDFDFFFF 		offset ABS
 1249 0950 56FBFFFF 		offset SWAP
 1250 0954 D5FDFFFF 		offset ABS
GAS LISTING nv32forth.s 			page 26


 1251 0958 93FFFFFF 		offset UStar
 1252 095c 08FBFFFF 		offset FromR
 1253 0960 53FFFFFF 		offset DPlusMinus
 1254 0964 E6090000 		offset SemiS
 1255              	
 1256              	 #	: M/		( a.lo a.hi b -- rem quo )
 1257              	 #	  OVER >R >R DABS R ABS U/
 1258              	 #	  R> R XOR +- SWAP
 1259              	 #	  R> +- SWAP
 1260              	 #	;
 1261              	 #
 1262              	 #	This word divids the double-precision number a by the single-
 1263              	 #	precision number b, returning both the remainder and the quotient.
 1264              	
 1265 0968 A24D2FCA 		colon "MSlash","M/","MStar"
 1265      FFFFFFA5 
 1265      F9FFFF
 1266 0973 6EFBFFFF 		offset OVER
 1267 0977 DDFAFFFF 		offset ToR
 1268 097b D9FAFFFF 		offset ToR
 1269 097f 55FFFFFF 		offset DABS
 1270 0983 F0FAFFFF 		offset R
 1271 0987 A2FDFFFF 		offset ABS
 1272 098b 78FFFFFF 		offset USlash
 1273 098f D5FAFFFF 		offset FromR
 1274 0993 E0FAFFFF 		offset R
 1275 0997 3BFCFFFF 		offset XOR
 1276 099b 6EFDFFFF 		offset PlusMinus
 1277 099f 07FBFFFF 		offset SWAP
 1278 09a3 C1FAFFFF 		offset FromR
 1279 09a7 62FDFFFF 		offset PlusMinus
 1280 09ab FBFAFFFF 		offset SWAP
 1281 09af 9B090000 		offset SemiS
 1282              	
 1283              	 #	: M/MOD		( ud1.hi ud1.lo u2 -- remainder quo.hi quo.lo )
 1284              	 #	  >R 0 R	( -- ud1.hi ud1.lo 0 u2 )
 1285              	 #	  U/ 		( -- ud1.hi rem1 quot1 )
 1286              	 #	  R> SWAP	( -- ud1.hi rem1 u2 quot1 ) 
 1287              	 #	  >R		( -- ud1.hi rem1 u2 )
 1288              	 #	  U/		( -- rem2 quot2 )
 1289              	 #	  R>		( -- rem2 quot2 quot1 )
 1290              	 #	;
 1291              	 #
 1292              	 #	This word divides a double-precision number by an unsigned single-
 1293              	 #	precision number. 
 1294              	
 1295 09b3 A54D2F4D 		colon "MSlashMod","M/MOD","MSlash"
 1295      4F44AFFF 
 1295      FFFF57F9 
 1295      FFFF
 1296 09c1 93FAFFFF 		offset ToR
 1297 09c5 71130000 		offset Zero
 1298 09c9 AAFAFFFF 		offset R
 1299 09cd 36FFFFFF 		offset USlash
 1300 09d1 93FAFFFF 		offset FromR
 1301 09d5 D1FAFFFF 		offset SWAP
 1302 09d9 7BFAFFFF 		offset ToR
GAS LISTING nv32forth.s 			page 27


 1303 09dd 26FFFFFF 		offset USlash
 1304 09e1 83FAFFFF 		offset FromR
 1305 09e5 65090000 		offset SemiS
 1306              	
 1307              	 #	@: addr -- mem[addr]
 1308              	 #
 1309              	 #	Fetches the longword at the specified address.
 1310              	
 1311 09e9 A140C8FF 		code "Fetch","@","MSlashMod"
 1311      FFFF0400 
 1311      0000
 1312 09f3 D0B70067 		movl *(r7),(r7)
 1313 09f7 176B     		jmp (r11)
 1314              	
 1315              	 #	C@: addr -- mem[addr], byte
 1316              	 #
 1317              	 #	Fetches the byte at the specified address. The byte is zero-extended.
 1318              	
 1319 09f9 A24340ED 		code "CFetch","C@","Fetch"
 1319      FFFFFF04 
 1319      000000
 1320 0a04 9AB70067 		movzbl *(r7),(r7)
 1321 0a08 176B     		jmp (r11)
 1322              	
 1323              	 #	2@: addr -- mem[addr+1] mem[addr]
 1324              	 #
 1325              	 #	This procedure fetches the quadword addressed by the top of the math
 1326              	 #	stack and stores it on the math stack. I didn't use a quadword
 1327              	 #	instruction because the words would be stacked in the wrong order.
 1328              	
 1329 0a0a A23240EC 		code "TFetch","2@","CFetch"
 1329      FFFFFF04 
 1329      000000
 1330 0a15 D08750   		movl (r7)+,r0		# Get the address
 1331 0a18 D0A00477 		movl 4(r0),-(r7)	# Fetch high-order longword
 1332 0a1c D06077   		movl (r0),-(r7)		# Fetch low-order longword
 1333 0a1f 176B     		jmp (r11)
 1334              	
 1335              	 #	!: val addr -- <set mem[addr] = val>
 1336              	 #
 1337              	 #	This procedure stores a longword to the address stored at the top
 1338              	 #	of the math stack. The value stored is the second item on the math
 1339              	 #	stack.
 1340              	
 1341 0a21 A121E7FF 		code "Store","!","TFetch"
 1341      FFFF0400 
 1341      0000
 1342 0a2b D0A70497 		movl 4(r7),*(r7)+	# Store value and discard address
 1343 0a2f D587     		tstl (r7)+		# Discard value
 1344 0a31 176B     		jmp (r11)
 1345              	
 1346              	 #	C!: val addr -- <set mem[addr] = val as a byte>
 1347              	 #
 1348              	 #	This procedure stores a byte to the address stored at the top of
 1349              	 #	the math stack. The value stored is the second item on the math
 1350              	 #	stack.
 1351              	
GAS LISTING nv32forth.s 			page 28


 1352 0a33 A24321EB 		code "CStore","C!","Store"
 1352      FFFFFF04 
 1352      000000
 1353 0a3e 90A70497 		movb 4(r7),*(r7)+	# Store value and discard address
 1354 0a42 D587     		tstl (r7)+		# Discard value
 1355 0a44 176B     		jmp (r11)
 1356              	
 1357              	 #	2!: val1 val2 addr -- <mem[addr] = val2, mem[addr+1] = val1>
 1358              	 #
 1359              	 #	This procedure stores a quadword from the math stack to memory.
 1360              	
 1361 0a46 A23221EA 		code "TStore","2!","CStore"
 1361      FFFFFF04 
 1361      000000
 1362 0a51 7DA70497 		movq 4(r7),*(r7)+	# Store value and discard address
 1363 0a55 C00857   		addl2 $8,r7		# Discard val1 and val2
 1364 0a58 176B     		jmp (r11)
 1365              	
 1366              	 #	: ++		( ADDR -- <INCREMENTS VAL AT ADDR> )
 1367              	 #	  1 SWAP +! ;
 1368              	 #
 1369              	 #	This is an extension from C-Forth. Looked useful to me, so I
 1370              	 #	kept it.
 1371              	
 1372 0a5a A22B2BE9 		colon "PlusPlus","++","TStore"
 1372      FFFFFFB3 
 1372      F8FFFF
 1373 0a65 DF120000 		offset One
 1374 0a69 3DFAFFFF 		offset SWAP
 1375 0a6d 75FBFFFF 		offset PlusStore
 1376 0a71 D9080000 		offset SemiS
 1377              	
 1378              	 #	: --		( ADDR -- <DECREMENTS VAL AT ADDR> )
 1379              	 #	  -1 SWAP +! ;
 1380              	 #
 1381              	 #	This is an extension from C-Forth. Looked useful to me, so I
 1382              	 #	kept it.
 1383              	
 1384 0a75 A22D2DE2 		colon "MinusMinus","--","PlusPlus"
 1384      FFFFFF98 
 1384      F8FFFF
 1385 0a80 C3000000 		literal -1
 1385      FFFFFFFF 
 1386 0a88 1EFAFFFF 		offset SWAP
 1387 0a8c 56FBFFFF 		offset PlusStore
 1388 0a90 BA080000 		offset SemiS
 1389              	
 1390              	 #	: CVTWL@	( addr -- sign-extended word )
 1391              	 #			( fetch a sign-extended word )
 1392              	 #
 1393              	 #	This word fetchs a 16-bit word and sign-extends it to a 32-bit
 1394              	 #	longword before pushing it on the math stack. This is needed for
 1395              	 #	fetching relative offset from the code portion of a FORTH word,
 1396              	 #	for example.
 1397              	
 1398 0a94 A6435654 		code "CVTWLFetch","CVTWL@","MinusMinus"
 1398      574C40DA 
GAS LISTING nv32forth.s 			page 29


 1398      FFFFFF04 
 1398      000000
 1399 0aa3 32B70067 		cvtwl *(r7),(r7)
 1400 0aa7 176B     		jmp (r11)
 1401              	
 1402              	 #	: W!		( value address -- )
 1403              	 #			store a word
 1404              	 #
 1405              	 #	This word stores a 16-bit word at the specified address.
 1406              	
 1407 0aa9 A25721E8 		code "WStore","W!","CVTWLFetch"
 1407      FFFFFF04 
 1407      000000
 1408 0ab4 B0A70497 		movw 4(r7),*(r7)+
 1409 0ab8 D587     		tstl (r7)+	# Discard value
 1410 0aba 176B     		jmp (r11)
 1411              	
 1412              	 #	cmove: source dest number --
 1413              	 #
 1414              	 #	This procedure moves number bytes from source to dest. MOVC3
 1415              	 #	won't work because the regions might overlap and MOVC3 is too
 1416              	 #	highly optimized for that (perhaps our minds are _too_ highly
 1417              	 #	trained, Vroomfondel).
 1418              	
 1419 0abc A5434D4F 		code "CMOVE","CMOVE","WStore"
 1419      5645E7FF 
 1419      FFFF0400 
 1419      0000
 1420 0aca 90B708B7 	CMove1:	movb *8(r7),*4(r7)	# Move a byte
 1420      04
 1421 0acf D6A708   		incl 8(r7)		# Advance source
 1422 0ad2 D6A704   		incl 4(r7)		# Advance dest
 1423 0ad5 F567F2   		sobgtr (r7),CMove1	# Lather, rinse, and repeat
 1424 0ad8 C00C57   		addl2 $12,r7		# Toss number, dest, and source
 1425 0adb 176B     		jmp (r11)
 1426              	
 1427              	 #	: FILL		( START COUNT VALUE -- <FILL COUNT BYTES, FROM
 1428              	 #			  START, WITH VALUE )
 1429              	 #
 1430              	 #	This word fills memory starting at START with the VALUE. Memory
 1431              	 #	is filled as bytes, so if VALUE is bigger than a byte it's
 1432              	 #	truncated during the storage process. COUNT bytes are filled.
 1433              	 #	If COUNT is 0, no bytes are filled.
 1434              	 #
 1435              	 #	$$$
 1436              	
 1437 0add A446494C 		code "FILL","FILL","CMOVE"
 1437      4CDAFFFF 
 1437      FF040000 
 1437      00
 1438 0aea D5A704   		tstl 4(r7)		# Did we get a zero count?
 1439 0aed 1312     		beql FILL1		# If so, go
 1440              	
 1441              					# Now make the stack look good like what
 1442              					# CMOVE wants
 1443              	
 1444 0aef 9067B708 		movb (r7),*8(r7)	# Prime the pump
GAS LISTING nv32forth.s 			page 30


 1445 0af3 C301A704 		subl3 $1,4(r7),(r7)	# Adjust the count to account for the priming
 1445      67
 1446 0af8 C101A708 		addl3 $1,8(r7),4(r7)	# Dest is just after the priming
 1446      A704
 1447 0afe 17AFC9   		jmp CMOVE_pfa		# Shazam!!!
 1448              	
 1449 0b01 C00C67   	FILL1:	addl2 $12,(r7)		# DROP the arguments
 1450 0b04 176B     		jmp (r11)		# Return to caller
 1451              	
 1452              	 #	: ERASE		( START COUNT -- <ZERO OUT MEMORY> )
 1453              	 #	  0 FILL
 1454              	 #	;
 1455              	 #
 1456              	 #	This word fills a chunk of memory with zeros.
 1457              	
 1458 0b06 A5455241 		colon "ERASE","ERASE","FILL"
 1458      5345D1FF 
 1458      FFFF04F8 
 1458      FFFF
 1459 0b14 22120000 		offset Zero
 1460 0b18 CEFFFFFF 		offset FILL
 1461 0b1c 2E080000 		offset SemiS
 1462              	
 1463              	 #	: BLANKS	( START COUNT -- <FILL WITH BLANKS> )
 1464              	 #	  BL FILL
 1465              	 #	;
 1466              	 #
 1467              	 #	This word fills a chunk of memory with blanks.
 1468              	
 1469 0b20 A6424C41 		colon "BLANKS","BLANKS","ERASE"
 1469      4E4B53DF 
 1469      FFFFFFE9 
 1469      F7FFFF
 1470 0b2f E9110000 		offset BL		# start count 32
 1471 0b33 B3FFFFFF 		offset FILL
 1472 0b37 13080000 		offset SemiS
 1473              	
 1474              	 #	LIT: Push word following onto math stack
 1475              	 #
 1476              	 #	The opcode is followed by a longword. This longword is fetched
 1477              	 #	via IP and pushed onto the math stack. The longword is then skipped.
 1478              	
 1479 0b3b A34C4954 		code "LIT","LIT","BLANKS"
 1479      E1FFFFFF 
 1479      04000000 
 1480 0b47 D08A77   		movl (r10)+,-(r7)	# Push the literal and update IP.
 1481 0b4a 176B     		jmp (r11)
 1482              	
 1483              	 #	ZBLIT: Push byte following onto math stack
 1484              	 #
 1485              	 #	The opcode is followed by a byte. This byte is fetched via IP,
 1486              	 #	zero-extended, and pushed on the math stack. The byte is then
 1487              	 #	skipped.
 1488              	
 1489 0b4c A55A424C 		code "ZBLIT","ZBLIT","LIT"
 1489      4954E9FF 
 1489      FFFF0400 
GAS LISTING nv32forth.s 			page 31


 1489      0000
 1490 0b5a 9A8A77   		movzbl (r10)+,-(r7)	# Push the literal and update IP.
 1491 0b5d 176B     		jmp (r11)
 1492              	
 1493              	 #	OLIT: Push word referred to by following offset onto math stack
 1494              	 #
 1495              	 #	This opcode is followed by a relative offset. The address to
 1496              	 #	which that offset refers is pushed on the math stack.
 1497              	
 1498 0b5f A44F4C49 		code "OLIT","OLIT","ZBLIT"
 1498      54E8FFFF 
 1498      FF040000 
 1498      00
 1499 0b6c C15A8A77 		addl3 r10,(r10)+,-(r7)	# Relocate and push the offset.
 1500 0b70 176B     		jmp (r11)
 1501              	
 1502              	 #	: LITERAL
 1503              	 #	  STATE @
 1504              	 #	  0BRANCH L1
 1505              	 #	  COMPILE LIT ,
 1506              	 #	LABEL L1
 1507              	 #	;*
 1508              	 #
 1509              	 #	This word compiles a single-precision literal into the current
 1510              	 #	word if we're compiling. If we're not compiling, it's a NOP so you
 1511              	 #	can say LITERAL 0 at the OK prompt and not get an error.
 1512              	 #
 1513              	 #	This word is not smart enough to optimize byte-sized literals into
 1514              	 #	a reference to ZBLIT followed by the byte. Sigh; maybe sometime,
 1515              	 #	although I doubt this code will survive much beyond the NV5 <-> APECS
 1516              	 #	demo.
 1517              	
 1518 0b72 E74C4954 		colon "LITERAL","LITERAL","OLIT",Immediate
 1518      4552414C 
 1518      E5FFFFFF 
 1518      96F7FFFF 
 1519 0b82 34110000 		offset STATE		# Are we compiling?
 1520 0b86 69FEFFFF 		offset Fetch
 1521 0b8a D5F7FFFF 		offset ZBranch		# If not, go
 1522 0b8e 10000000 		offset L1
 1523 0b92 CA0A0000 		offset COMPILE		# Otherwise, do the LIT thing
 1524 0b96 ADFFFFFF 		offset LIT
 1525 0b9a 7A000000 		offset Comma
 1526 0b9e AC070000 	L1:	offset SemiS
 1527              	
 1528              	 #	: DLITERAL
 1529              	 #	  STATE @
 1530              	 #	  0BRANCH D1
 1531              	 #	  SWAP LITERAL LITERAL
 1532              	 #	LABEL D1
 1533              	 #	;*
 1534              	 #
 1535              	 #	This procedure compiles a double-precision literal into the code, if
 1536              	 #	we're compiling. If not compiling, it's a NOP; this may be viewed as
 1537              	 #	a bug or a feature (typing DLITERAL 0 at the OK prompt does _not_
 1538              	 #	put a double-precision 0 on the math stack).
 1539              	
GAS LISTING nv32forth.s 			page 32


 1540 0ba2 A8444C49 		colon "DLITERAL","DLITERAL","LITERAL"
 1540      54455241 
 1540      4CC7FFFF 
 1540      FF65F7FF 
 1540      FF
 1541 0bb3 03110000 		offset STATE		# Are we compiling?
 1542 0bb7 38FEFFFF 		offset Fetch
 1543 0bbb A4F7FFFF 		offset ZBranch		# If not, go.
 1544 0bbf 10000000 		offset D1
 1545 0bc3 E3F8FFFF 		offset SWAP		# We need to push second on stack first.
 1546 0bc7 B7FFFFFF 		offset LITERAL		# Do a single-precision literal for second.
 1547 0bcb B3FFFFFF 		offset LITERAL		# Do a single-precision literal for first.
 1548 0bcf 7B070000 	D1:	offset SemiS
 1549              	
 1550              	 #	: HERE		( -- DP )
 1551              	 #	  DP @ ;
 1552              	 #
 1553              	 #	This word returns the current end of the dictionary.
 1554              	
 1555 0bd3 A4484552 		colon "HERE","HERE","DLITERAL"
 1555      45CAFFFF 
 1555      FF38F7FF 
 1555      FF
 1556 0be0 A1100000 		offset DP
 1557 0be4 0BFEFFFF 		offset Fetch
 1558 0be8 62070000 		offset SemiS
 1559              	
 1560              	 #	: allot			( n -- )
 1561              	 #	  here + dp !		( allocate specified number of bytes from
 1562              	 #				  the directory )
 1563              	 #	;
 1564              	 #
 1565              	 #	This word allocates space at the end of the dictionary. It adds
 1566              	 #	the specified number to the dictionary pointer, advancing the
 1567              	 #	dictionary pointer past the specified number of bytes.
 1568              	
 1569 0bec A5414C4C 		colon "ALLOT","ALLOT","HERE"
 1569      4F54E1FF 
 1569      FFFF1EF7 
 1569      FFFF
 1570 0bfa E2FFFFFF 		offset HERE
 1571 0bfe 92FAFFFF 		offset Plus
 1572 0c02 7F100000 		offset DP
 1573 0c06 21FEFFFF 		offset Store
 1574 0c0a 40070000 		offset SemiS
 1575              	
 1576              	 #	: ,		( V -- <PLACES V AT DP AND INCREMENTS DP>)
 1577              	 #	  HERE !
 1578              	 #	  4 ALLOT ;
 1579              	 #
 1580              	 #	This word compiles a longword into the dictionary by storing
 1581              	 #	the longword at here and advancing the pointer over it.
 1582              	
 1583 0c0e A12CDCFF 		colon "Comma",",","ALLOT"
 1583      FFFF00F7 
 1583      FFFF
 1584 0c18 C4FFFFFF 		offset HERE	# Store the word at the end of the dictionary
GAS LISTING nv32forth.s 			page 33


 1585 0c1c 0BFEFFFF 		offset Store
 1586 0c20 23FFFFFF 		literal 4	# Advance the end of the dictionary over it
 1586      04000000 
 1587 0c28 CEFFFFFF 		offset ALLOT
 1588 0c2c 1E070000 		offset SemiS
 1589              	
 1590              	 #	: w,		( w -- <places word at dp and increments dp> )
 1591              	 #	  here w!
 1592              	 #	  2 allot ;
 1593              	 #
 1594              	 #	This word is needed since I'm using 16-bit offsets for all of my
 1595              	 #	threads. It stores a word at the end of the dictionary and advances
 1596              	 #	the dictionary over it.
 1597              	
 1598 0c30 A2572CDB 		colon "WComma","W,","Comma"
 1598      FFFFFFDD 
 1598      F6FFFF
 1599 0c3b A1FFFFFF 		offset HERE	# Store the 16-bit word
 1600 0c3f 71FEFFFF 		offset WStore
 1601 0c43 0F110000 		offset Two	# Advance the dictionary past it
 1602 0c47 AFFFFFFF 		offset ALLOT
 1603 0c4b FF060000 		offset SemiS
 1604              	
 1605              	 #	: C,	( C -- <COMPILE A CHARACTER. SAME AS , WHEN WORDSIZE = 1 > )
 1606              	 #	  HERE C!
 1607              	 #	  1 ALLOT ;
 1608              	 #
 1609              	 #	This word compiles a byte into the dictionary; it stores the byte
 1610              	 #	at the end of the dictionary and advances the dictionary past it.
 1611              	
 1612 0c4f A2432CDE 		colon "CComma","C,","WComma"
 1612      FFFFFFBE 
 1612      F6FFFF
 1613 0c5a 82FFFFFF 		offset HERE	# Store the byte
 1614 0c5e DCFDFFFF 		offset CStore
 1615 0c62 E2100000 		offset One	# Advance the dictionary past it
 1616 0c66 90FFFFFF 		offset ALLOT
 1617 0c6a E0060000 		offset SemiS
 1618              	
 1619              	 #	: o,			( n -- )
 1620              	 #	  here - ,
 1621              	 #	;
 1622              	 #
 1623              	 #	This word compiles a relative offset INto the dictionary; that is,
 1624              	 #	it compiles a word offset to the specified address.
 1625              	
 1626 0c6e A24F2CDE 		colon "OComma","O,","CComma"
 1626      FFFFFF9F 
 1626      F6FFFF
 1627 0c79 63FFFFFF 		offset HERE
 1628 0c7d 0AF9FFFF 		offset Subtract
 1629 0c81 93FFFFFF 		offset Comma
 1630 0c85 C5060000 		offset SemiS
 1631              	
 1632              	 #	key: -- c <get next char from input>
 1633              	 #
 1634              	 #	This word waits for a character to be typed at the console and
GAS LISTING nv32forth.s 			page 34


 1635              	 #	returns that character.
 1636              	
 1637 0c89 A34B4559 		code "KEY","KEY","OComma"
 1637      E1FFFFFF 
 1637      04000000 
 1638 0c95 3096F3   		bsbw ConIn		# Get the character
 1639 0c98 9A5077   		movzbl r0,-(r7)		# Push it
 1640 0c9b 176B     		jmp (r11)
 1641              	
 1642              	 #	?key: -- 0 ( no character available )
 1643              	 #	         non-zero ( character available )
 1644              	 #
 1645              	 #	This word checks to see if a character is available at the
 1646              	 #	console.
 1647              	
 1648 0c9d A43F4B45 		code "QKey","?KEY","KEY"
 1648      59E7FFFF 
 1648      FF040000 
 1648      00
 1649 0caa 3096F3   		bsbw ConSt		# Check status
 1650 0cad 9A5077   		movzbl r0,-(r7)		# Push it
 1651 0cb0 176B     		jmp (r11)
 1652              	
 1653              	 #	emit: c -- <put char to output>
 1654              	 #
 1655              	 #	This word displays a character on the console.
 1656              	 #
 1657              	 #	$$$
 1658              	
 1659 0cb2 A4454D49 		code "EMIT","EMIT","QKey"
 1659      54E6FFFF 
 1659      FF040000 
 1659      00
 1660 0cbf 9A6750   		movzbl (r7),r0		# Get the character
 1661 0cc2 D587     		tstl (r7)+
 1662 0cc4 300300   		bsbw FConOut		# Print it
 1663 0cc7 176B     		jmp (r11)
 1664              	
 1665 0cc9 00       	invis:	.byte 0
 1666              	
 1667              	 #	FConOut: routine to conditionally display info on the console;
 1668              	 #
 1669              	 #	This routine is a wrapper for the BIOS ConOut that allows console
 1670              	 #	display to be inhibitted during download from a bit-banged serial
 1671              	 #	port (such as the SROM port of the NV5). If output is invisible,
 1672              	 #	ConOut is not called. If output is not invisible, ConOut is called.
 1673              	
 1674              	FConOut:
 1675 0cca 95AFFC   		tstb invis
 1676 0ccd 1303     		beql fconout1
 1677 0ccf 3186F3   		brw ConOut
 1678 0cd2 05       	fconout1: rsb
 1679              	
 1680              	 #	.off
 1681              	 #
 1682              	 #	This word turns EMIT off so that it won't print anything. This is
 1683              	 #	needed when downloading code through the bit-banged serial port so
GAS LISTING nv32forth.s 			page 35


 1684              	 #	the NV5 can get ready for the next character without wasting time
 1685              	 #	echoing the character.
 1686              	 #
 1687              	 #	$$$
 1688              	
 1689 0cd3 A42E4F46 		code "DotOff",".OFF","EMIT"
 1689      46DAFFFF 
 1689      FF040000 
 1689      00
 1690 0ce0 94AFE6   		clrb invis
 1691 0ce3 176B     		jmp (r11)
 1692              	
 1693              	 #	.on
 1694              	 #
 1695              	 #	This word turns EMIT back on after it has been disabled by .off.
 1696              	 #	Used to end a download sequence.
 1697              	 #
 1698              	 #	$$$
 1699              	
 1700 0ce5 A32E4F4E 		code "DotOn",".ON","DotOff"
 1700      EAFFFFFF 
 1700      04000000 
 1701 0cf1 9001AFD4 		movb $1,invis
 1702 0cf5 176B     		jmp (r11)
 1703              	
 1704              	 #	?terminal: <see if op. interrupted <like w/^C>>
 1705              	 #
 1706              	 #	Since we can't check for ^C on the bit-banged console port of
 1707              	 #	the NV5, and we don't know what to do with keys that come in
 1708              	 #	which aren't ^Cs anyway, I'm stubbing it.
 1709              	 #
 1710              	 #	Beware the infinite loop...
 1711              	
 1712 0cf7 A93F5445 		code "QTerminal","?TERMINAL","DotOn"
 1712      524D494E 
 1712      414CE4FF 
 1712      FFFF0400 
 1712      0000
 1713 0d09 D477     		clrl -(r7)
 1714 0d0b 176B     		jmp (r11)
 1715              	
 1716              	 #	: CR			( -- )
 1717              	 #	  LIT 13 EMIT
 1718              	 #	  LIT 10 EMIT
 1719              	 #
 1720              	 #	This word advances the cursor to the next line by displaying a
 1721              	 #	carriage return/linefeed sequence.
 1722              	 #
 1723              	 #	$$$
 1724              	
 1725 0d0d A24352E7 		colon "CR","CR","QTerminal"
 1725      FFFFFF00 
 1725      F6FFFF
 1726 0d18 2BFEFFFF 		literal 13		# Display the carriage return
 1726      0D000000 
 1727 0d20 9BFFFFFF 		offset EMIT
 1728 0d24 1FFEFFFF 		literal 10
GAS LISTING nv32forth.s 			page 36


 1728      0A000000 
 1729 0d2c 8FFFFFFF 		offset EMIT		# Display the linefeed
 1730 0d30 1A060000 		offset SemiS
 1731              	
 1732              	 #	: SPACE ( EMIT A SPACE )
 1733              	 #	  BL EMIT ;
 1734              	 #
 1735              	 #	Display a space on the screen.
 1736              	
 1737 0d34 A5535041 		colon "SPACE","SPACE","CR"
 1737      4345D3FF 
 1737      FFFFD6F5 
 1737      FFFF
 1738 0d42 D60F0000 		offset BL
 1739 0d46 75FFFFFF 		offset EMIT
 1740 0d4a 00060000 		offset SemiS
 1741              	
 1742              	 #	: HEX		( GO TO HEXADECIMAL BASE )
 1743              	 #	  LIT 0x10 BASE ! ;
 1744              	 #
 1745              	 #	This word causes the system to use hexadecimal for all numeric
 1746              	 #	I/O.
 1747              	
 1748 0d4e A3484558 		colon "HEX","HEX","SPACE"
 1748      E2FFFFFF 
 1748      BEF5FFFF 
 1749 0d5a E9FDFFFF 		literal 0x10
 1749      10000000 
 1750 0d62 650F0000 		offset BASE
 1751 0d66 C1FCFFFF 		offset Store
 1752 0d6a E0050000 		offset SemiS
 1753              	
 1754              	 #	: DECIMAL	( GO TO DECIMAL BASE )
 1755              	 #	  LIT 0x0A BASE !
 1756              	 #	;
 1757              	 #
 1758              	 #	This word causes the system to use decimal for all numeric I/O.
 1759              	
 1760 0d6e A7444543 		colon "DECIMAL","DECIMAL","HEX"
 1760      494D414C 
 1760      D8FFFFFF 
 1760      9AF5FFFF 
 1761 0d7e C5FDFFFF 		literal 10
 1761      0A000000 
 1762 0d86 410F0000 		offset BASE
 1763 0d8a 9DFCFFFF 		offset Store
 1764 0d8e BC050000 		offset SemiS
 1765              	
 1766              	 #	digit: 		( c base -- 0 ) of c isn't a digit
 1767              	 #			( c base -- v 1 ) if c is a digit
 1768              	 #
 1769              	 #	This word looks to see if the ASCII character c is a digit in
 1770              	 #	the number base specified by base. If it is not a digit, 0 is
 1771              	 #	pushed. If it is a digit, the numeric value of that digit is
 1772              	 #	pushed followed by a 1.
 1773              	
 1774 0d92 A5444947 		code "DIGIT","DIGIT","DECIMAL"
GAS LISTING nv32forth.s 			page 37


 1774      4954D6FF 
 1774      FFFF0400 
 1774      0000
 1775 0da0 D08751   		movl (r7)+,r1		# Get the base
 1776 0da3 D08750   		movl (r7)+,r0		# Get the character
 1777              	
 1778 0da6 D13050   		cmpl $0x30,r0		# Is it smaller than '0'?
 1779 0da9 1A2F     		bgtru Digit_Nope	# No, go
 1780 0dab D13A50   		cmpl $0x3a,r0		# Is it bigger than '9'?
 1781 0dae 1F05     		blssu Digit_Alpha
 1782              	
 1783 0db0 823050   		subb2 $0x30,r0		# Convert it to a number (there won't
 1784 0db3 1118     		brb Digit_Test		# be any borrows)
 1785              	
 1786              	Digit_Alpha:
 1787 0db5 8A2050   		bicb2 $0x20,r0		# Make certain it's uppercase
 1788 0db8 D18F4000 		cmpl $0x41-1,r0		# Is it too small to be an alphadigit?
 1788      000050
 1789 0dbf 1A19     		bgtru Digit_Nope	# Yes, go
 1790 0dc1 D18F5A00 		cmpl $0x5a,r0		# Is it too big to be an alphadigit?
 1790      000050
 1791 0dc8 1F10     		blssu Digit_Nope	# Yes, go
 1792              	
 1793 0dca 823750   		subb2 $0x41-10,r0	# Make it 10 through 35
 1794              	Digit_Test:
 1795 0dcd D15051   		cmpl r0,r1		# Check against the base
 1796 0dd0 1A08     		bgtru Digit_Nope	# If too big, go
 1797              	
 1798 0dd2 D05077   		movl r0,-(r7)		# It's a digit. Push the value
 1799 0dd5 9A0177   		movzbl $1,-(r7)		# Push TRUE
 1800 0dd8 176B     		jmp (r11)
 1801              	
 1802              	Digit_Nope:			# It's not a digit
 1803 0dda D477     		clrl -(r7)		# Push FALSE
 1804 0ddc 176B     		jmp (r11)
 1805              	
 1806              	 #	: TYPE		( addr n -- ) ( displays n bytes from addr )
 1807              	 #
 1808              	 #	This word displays n bytes starting at addr on the console. It
 1809              	 #	depends on the BIOS not mutilating R5 and R6.
 1810              	 #
 1811              	 #	$$$
 1812              	
 1813 0dde A4545950 		code "TYPE","TYPE","DIGIT"
 1813      45AFFFFF 
 1813      FF040000 
 1813      00
 1814 0deb D08755   		movl (r7)+,r5		# Count to R5
 1815 0dee D08756   		movl (r7)+,r6		# Address to R6
 1816 0df1 9A8650   	Type1:	movzbl (r6)+,r0		# Get the character & bump address
 1817 0df4 30D3FE   		bsbw FConOut		# Display the character
 1818 0df7 F555F7   		sobgtr r5,Type1		# Repeat until done
 1819 0dfa 176B     		jmp (r11)
 1820              	
 1821              	 #	: COUNT			( ADDR -- ADDR+1 COUNT )
 1822              	 #
 1823              	 #	This word fetches the byte at ADDR and increments ADDR. This takes
GAS LISTING nv32forth.s 			page 38


 1824              	 #	a string of the form <count><body> (such as all of the in-line
 1825              	 #	strings) and converts it to a form suitable for TYPE.
 1826              	 #
 1827              	 #	$$$
 1828              	
 1829 0dfc A5434F55 		code "COUNT","COUNT","TYPE"
 1829      4E54DCFF 
 1829      FFFF0400 
 1829      0000
 1830 0e0a 9AB70077 		movzbl *(r7),-(r7)
 1831 0e0e D6A704   		incl 4(r7)
 1832 0e11 176B     		jmp (r11)
 1833              	
 1834              	 #	: (.")			( PRINT A COMPILED STRING )
 1835              	 #	  R COUNT
 1836              	 #	  DUP 1+ R> + >R TYPE
 1837              	 #	;
 1838              	 #
 1839              	 #	This word is the run-time action of ."; it prints out a string
 1840              	 #	embedded in the word.
 1841              	
 1842 0e13 A4282E22 		colon "PDotQuote","(.\")","COUNT"
 1842      29E4FFFF 
 1842      FFF8F4FF 
 1842      FF
 1843 0e20 53F6FFFF 		offset R		# return address
 1844 0e24 E2FFFFFF 		offset COUNT		# ra+1 count
 1845 0e28 CBF6FFFF 		offset DUP		# ra+1 count count
 1846 0e2c 98F8FFFF 		offset OnePlus		# ra+1 count count+1
 1847 0e30 34F6FFFF 		offset FromR		# ra+1 count count+1 ra
 1848 0e34 5CF8FFFF 		offset Plus		# ra+1 count ra+count+1 (skip string)
 1849 0e38 1CF6FFFF 		offset ToR		# ra+1 count
 1850 0e3c ABFFFFFF 		offset TYPE
 1851 0e40 0A050000 		offset SemiS
 1852              	
 1853              	 #	: ."			( COMPILE A STRING IF COMPILING,
 1854              	 #				  OR PRINT A STRING IF INTERPRETING )
 1855              	 #	  LIT '"'
 1856              	 #	  STATE @
 1857              	 #	  0BRANCH QUOTE1
 1858              	 #	  COMPILE (.") WORD HERE C@ 1+ ALLOT	( IF )
 1859              	 #	  BRANCH QUOTE2
 1860              	 #	LABEL QUOTE1
 1861              	 #	  WORD HERE COUNT TYPE			( ELSE )
 1862              	 #	LABEL QUOTE2
 1863              	 #	;*
 1864              	 #
 1865              	 #	This word behaves differently depending on whether the FORTH system
 1866              	 #	is compiling or interpreting.
 1867              	 #
 1868              	 #	If the FORTH system is compiling, it compiles the string immediately
 1869              	 #	following it into the current word after (."). When the word is 
 1870              	 #	executed, the string will be printed.
 1871              	 #
 1872              	 #	If the FORTH system is not compiling, it prints out the string
 1873              	 #	immediately following it in the terminal input buffer.
 1874              	
GAS LISTING nv32forth.s 			page 39


 1875 0e44 E22E22CC 		colon "DotQuote",".\"","PDotQuote",Immediate
 1875      FFFFFFC9 
 1875      F4FFFF
 1876 0e4f F4FCFFFF 		literal 0x22	# quote
 1876      22000000 
 1877 0e57 5F0E0000 		offset STATE
 1878 0e5b 94FBFFFF 		offset Fetch
 1879 0e5f 00F5FFFF 		offset ZBranch
 1880 0e63 28000000 		offset Quote1
 1881 0e67 F5070000 		offset COMPILE
 1882 0e6b B1FFFFFF 		offset PDotQuote
 1883 0e6f 35090000 		offset WORD
 1884 0e73 69FDFFFF 		offset HERE
 1885 0e77 89FBFFFF 		offset CFetch
 1886 0e7b 49F8FFFF 		offset OnePlus
 1887 0e7f 77FDFFFF 		offset ALLOT
 1888 0e83 C7F4FFFF 		offset BRANCH
 1889 0e87 14000000 		offset Quote2
 1890 0e8b 19090000 	Quote1:	offset WORD
 1891 0e8f 4DFDFFFF 		offset HERE
 1892 0e93 73FFFFFF 		offset COUNT
 1893 0e97 50FFFFFF 		offset TYPE
 1894 0e9b AF040000 	Quote2:	offset SemiS
 1895              	
 1896              	 #	: QUERY
 1897              	 #	  TIB @		( ADDRESS OF BUFFER )
 1898              	 #	  B/BUF @	( SIZE OF BUFFER )
 1899              	 #	  EXPECT	( GET A LINE )
 1900              	 #	  O IN !	( PREPARE FOR INTERPRET )
 1901              	 #	;
 1902              	 #
 1903              	 #	This word reads a line from the console into the terminal input
 1904              	 #	buffer. It also initializes IN, a variable used by the interpreter
 1905              	 #	to keep track of its progress in the terminal input buffer.
 1906              	
 1907              	#	colon "QUERY","QUERY","DotQuote"
 1908              	#	offset TIB
 1909              	#	offset Fetch
 1910              	#	offset BSlashBuf
 1911              	#	offset Fetch
 1912              	#	offset EXPECT
 1913              	#	offset Zero
 1914              	#	offset IN
 1915              	#	offset Store
 1916              	#	offset SemiS
 1917              	
 1918 0e9f A5515545 		colon "QUERY","QUERY","DotQuote"
 1918      52599FFF 
 1918      FFFF6BF4 
 1918      FFFF
 1919              	
 1920 0ead B50D0000 		offset PTib	# Fetch a line via BDOS function 10
 1921 0eb1 3EFBFFFF 		offset Fetch
 1922 0eb5 8EFCFFFF 		literal 10
 1922      0A000000 
 1923 0ebd D30E0000 		offset BDOS
 1924 0ec1 44F6FFFF 		offset DROP
GAS LISTING nv32forth.s 			page 40


 1925 0ec5 4FFEFFFF 		offset CR
 1926              	
 1927 0ec9 6D0E0000 		offset Zero	# -- 0
 1928 0ecd 950D0000 		offset PTib	# Drop a null at the end of the line.
 1929 0ed1 1EFBFFFF 		offset Fetch
 1930 0ed5 EFF7FFFF 		offset OnePlus  # -- 0, addr of length read
 1931 0ed9 27FBFFFF 		offset CFetch	# -- 0, length read
 1932 0edd 950D0000 		offset TIB
 1933 0ee1 0EFBFFFF 		offset Fetch
 1934 0ee5 ABF7FFFF 		offset Plus	# -- 0, TIB + length read
 1935 0ee9 51FBFFFF 		offset CStore
 1936              	
 1937 0eed 490E0000 		offset Zero	# Initialize IN
 1938 0ef1 9F0D0000 		offset IN
 1939 0ef5 32FBFFFF 		offset Store
 1940              	
 1941 0ef9 51040000 		offset SemiS
 1942              	
 1943              	 #	enclose: addr c -- addr first last next
 1944              	 #
 1945              	 #	This word looks through memory starting at addr to find a word
 1946              	 #	enclosed by the specified delimiter. The search ends either when
 1947              	 #	the delimiter is found or a null is found. WORD uses this word
 1948              	 #	to hack the TIB into pieces.
 1949              	 #
 1950              	 #	First is the offset from addr to the first character in the word;
 1951              	 #		that is, the offset to the first non-delimiter character
 1952              	 #	Last is the offset from addr to the character after the last
 1953              	 #		character in the word; that is, to the delimiter following
 1954              	 #		the word
 1955              	 #	Next is the offset from addr to the character at which the search
 1956              	 #		for the next word should begin; that is, the character
 1957              	 #		after the delimiter that ended the word
 1958              	
 1959 0efd A7454E43 		code "ENCLOSE","ENCLOSE","QUERY"
 1959      4C4F5345 
 1959      9AFFFFFF 
 1959      04000000 
 1960              	
 1961 0f0d 9A6750   		movzbl (r7),r0		# delim = pop();
 1962 0f10 D587     		tstl (r7)+
 1963 0f12 D06751   		movl (r7),r1		# current = pop(); push( current );
 1964 0f15 D452     		clrl r2			# offset = -1;
 1965 0f17 D752     		decl r2
 1966 0f19 D751     		decl r1			# current--;
 1967              	
 1968              	encl1:
 1969 0f1b D651     		incl r1			# current++;
 1970 0f1d D652     		incl r2			# offset++;
 1971 0f1f 916150   		cmpb (r1),r0		# if( mem[current] == delim ) goto encl1;
 1972 0f22 13F7     		beql encl1
 1973              	
 1974 0f24 D05277   		movl r2,-(r7)		# push( offset );
 1975 0f27 9561     		tstb (r1)		# if( mem[current] == NULL ) {
 1976 0f29 1209     		bneq encl2
 1977 0f2b C1015277 		addl3 $1,r2,-(r7)	#   offset++; push( offset ); offset--;
 1978 0f2f D05277   		movl r2,-(r7)		#   push( offset );
GAS LISTING nv32forth.s 			page 41


 1979 0f32 176B     		jmp (r11)		#   return
 1980              					# }
 1981              	
 1982              	encl2:
 1983 0f34 D651     		incl r1			# current++;
 1984 0f36 D652     		incl r2			# offset++;
 1985 0f38 916150   		cmpb (r1),r0		# if( mem[current] == delim ) goto encl4
 1986 0f3b 130C     		beql encl4
 1987 0f3d 9561     		tstb (r1)		# if( mem[current != NULL ) goto encl2
 1988 0f3f 12F3     		bneq encl2
 1989              	
 1990              					# /* mem[current] is null.. */
 1991 0f41 D05277   		movl r2,-(r7)		# push( offset );
 1992 0f44 D05277   		movl r2,-(r7)		# push( offset );
 1993 0f47 176B     		jmp (r11)		# return;
 1994              	
 1995              	encl4:				# /* Found the trailing delimiter */
 1996 0f49 D05277   		movl r2,-(r7)		# push( offset );
 1997 0f4c C1015277 		addl3 $1,r2,-(r7)	# offset++; push( offset );
 1998 0f50 176B     		jmp (r11)		# return;
 1999              	
 2000              	 #	: HOLD		( C -- <PLACE C AT --HLD> )
 2001              	 #	  HLD -- HLD @ C!
 2002              	 #	;
 2003              	 #
 2004              	 #	This word is used to place something in the pad during formatted
 2005              	 #	numeric output. The current location in the buffer is decremented
 2006              	 #	and the byte on top of the math stack is stored.
 2007              	
 2008 0f52 A4484F4C 		colon "HOLD","HOLD","ENCLOSE"
 2008      44A6FFFF 
 2008      FFB9F3FF 
 2008      FF
 2009 0f5f 980D0000 		offset HLD
 2010 0f63 19FBFFFF 		offset MinusMinus
 2011 0f67 900D0000 		offset HLD
 2012 0f6b 84FAFFFF 		offset Fetch
 2013 0f6f CBFAFFFF 		offset CStore
 2014 0f73 D7030000 		offset SemiS
 2015              	
 2016              	 #	: (NUMBER)		( num.lo num.hi addr -- num.lo num.hi addr )
 2017              	 #	LABEL NUM1
 2018              	 #	  1+
 2019              	 #	  DUP >R C@ BASE @ DIGIT
 2020              	 #	  0BRANCH NUM2			( WHILE )
 2021              	 #	  SWAP BASE @ U* DROP
 2022              	 #	  ROT BASE @ U* D+
 2023              	 #	  DPL @ 1+
 2024              	 #	  ZBRANCH NUM3
 2025              	 #	  DPL ++			( IF )
 2026              	 #	LABEL NUM3
 2027              	 #	  R>				( ENDIF )
 2028              	 #	  BRANCH NUM1			( REPEAT )
 2029              	 #	LABEL NUM2
 2030              	 #	  R>
 2031              	 #	;
 2032              	 #
GAS LISTING nv32forth.s 			page 42


 2033              	 #	This word collects ASCII digits starting at the specified address
 2034              	 #	into a binary double-length number. The digits are added to the
 2035              	 #	original double-length number on the stack; it is expected that
 2036              	 #	conversion will be interrupted when a decimal point is found and
 2037              	 #	resumed afterwards.
 2038              	 #
 2039              	 #	As digits are accumulated, the count of digits after the decimal
 2040              	 #	point is maintained in DPL. If DPL is -1, it is assumed that a
 2041              	 #	decimal point has not yet been found and DPL is not modified. If
 2042              	 #	DPL is not -1, it is assumed that a decimal point has been found.
 2043              	 #	For each digit that is succesfully converted, DPL is incremented.
 2044              	 #
 2045              	 #	Conversion continues until a non-digit character is encountered.
 2046              	 #	At exit, addr is the address of this non-digit character.
 2047              	
 2048 0f77 A8284E55 		colon "PNumber","(NUMBER)","HOLD"
 2048      4D424552 
 2048      29D2FFFF 
 2048      FF90F3FF 
 2048      FF
 2049 0f88 3CF7FFFF 	Num1:	offset OnePlus
 2050 0f8c 67F5FFFF 		offset DUP
 2051 0f90 C4F4FFFF 		offset ToR
 2052 0f94 6CFAFFFF 		offset CFetch
 2053 0f98 2F0D0000 		offset BASE
 2054 0f9c 53FAFFFF 		offset Fetch
 2055 0fa0 FCFDFFFF 		offset DIGIT
 2056 0fa4 BBF3FFFF 		offset ZBranch
 2057 0fa8 54000000 		offset Num2
 2058 0fac FAF4FFFF 		offset SWAP
 2059 0fb0 170D0000 		offset BASE
 2060 0fb4 3BFAFFFF 		offset Fetch
 2061 0fb8 33F9FFFF 		offset UStar
 2062 0fbc 49F5FFFF 		offset DROP
 2063 0fc0 00F5FFFF 		offset ROT
 2064 0fc4 030D0000 		offset BASE
 2065 0fc8 27FAFFFF 		offset Fetch
 2066 0fcc 1FF9FFFF 		offset UStar
 2067 0fd0 8EF8FFFF 		offset DPlus
 2068 0fd4 030D0000 		offset DPL
 2069 0fd8 17FAFFFF 		offset Fetch
 2070 0fdc E8F6FFFF 		offset OnePlus
 2071 0fe0 7FF3FFFF 		offset ZBranch
 2072 0fe4 0C000000 		offset Num3
 2073 0fe8 EF0C0000 		offset DPL
 2074 0fec 75FAFFFF 		offset PlusPlus
 2075 0ff0 74F4FFFF 	Num3:	offset FromR
 2076 0ff4 56F3FFFF 		offset BRANCH
 2077 0ff8 90FFFFFF 		offset Num1
 2078 0ffc 68F4FFFF 	Num2:	offset FromR
 2079 1000 4A030000 		offset SemiS
 2080              	
 2081              	 #	: NUMBER		( addr -- val.lo val.hi )
 2082              	 #	  0 0 ROT DUP 1+ C@
 2083              	 #	  LIT '-' = DUP >R + -1
 2084              	 #	LABEL N1			( BEGIN )
 2085              	 #	  DPL ! (NUMBER) DUP C@ BL !=
GAS LISTING nv32forth.s 			page 43


 2086              	 #	  0BRANCH N2			( WHILE )
 2087              	 #	  DUP C@ LIT '.' != 0 ?ERROR 0	( . )
 2088              	 #	  BRANCH N1			( REPEAT )
 2089              	 #	LABEL N2
 2090              	 #	  DROP R>
 2091              	 #	  0BRANCH N3			( IF )
 2092              	 #	  DMINUS
 2093              	 #	LABEL N3
 2094              	 #	;
 2095              	 #
 2096              	 #	This word converts an ASCII digit string beginning at addr to a
 2097              	 #	binary number, returning the double-length value of that number.
 2098              	 #
 2099              	 #	Conversion is performed using (NUMBER). When (NUMBER) stops, the
 2100              	 #	offending character is examined. If it is a blank, the conversion
 2101              	 #	is done and NUMBER exits. If it is a decimal point, DPL is set to
 2102              	 #	zero to record the fact that a decimal point has been found and
 2103              	 #	(NUMBER) is re-entered. If the character is neither a blank nor
 2104              	 #	a decimal point, MSG # 0 is displayed.
 2105              	 #
 2106              	 #	By the way, I believe this word is the reason WORD insists that
 2107              	 #	there be a blank following the word that it has copied from TIB.
 2108              	 #	If INTERPRET cannot find a word in the dictionary, it assumes it
 2109              	 #	must be a number and hands it over to NUMBER. If the word did not
 2110              	 #	have a blank after it, the conversion would end on a non-blank
 2111              	 #	character and NUMBER would issue MSG # 0. What can I say? FORTH
 2112              	 #	seems to be held together by side-effects...
 2113              	
 2114 1004 A64E554D 		colon "NUMBER","NUMBER","PNumber"
 2114      4245526C 
 2114      FFFFFF05 
 2114      F3FFFF
 2115 1013 230D0000 		offset Zero
 2116 1017 1F0D0000 		offset Zero
 2117 101b A5F4FFFF 		offset ROT
 2118 101f D4F4FFFF 		offset DUP
 2119 1023 A1F6FFFF 		offset OnePlus
 2120 1027 D9F9FFFF 		offset CFetch
 2121 102b 18FBFFFF 		literal 0x2d		# <^A/-/>
 2121      2D000000 
 2122 1033 FEF5FFFF 		offset Equal
 2123 1037 BCF4FFFF 		offset DUP
 2124 103b 19F4FFFF 		offset ToR
 2125 103f 51F6FFFF 		offset Plus
 2126 1043 00FBFFFF 		literal -1
 2126      FFFFFFFF 
 2127 104b 8C0C0000 	N1:	offset DPL
 2128 104f D8F9FFFF 		offset Store
 2129 1053 31FFFFFF 		offset PNumber
 2130 1057 9CF4FFFF 		offset DUP
 2131 105b A5F9FFFF 		offset CFetch
 2132 105f B90C0000 		offset BL
 2133 1063 E0F5FFFF 		offset NotEq
 2134 1067 F8F2FFFF 		offset ZBranch
 2135 106b 2C000000 		offset N2
 2136 106f 84F4FFFF 		offset DUP
 2137 1073 8DF9FFFF 		offset CFetch
GAS LISTING nv32forth.s 			page 44


 2138 1077 CCFAFFFF 		literal 0x2e		# <^A/./>
 2138      2E000000 
 2139 107f C4F5FFFF 		offset NotEq
 2140 1083 B30C0000 		offset Zero
 2141 1087 51080000 		offset QError
 2142 108b AB0C0000 		offset Zero
 2143 108f BBF2FFFF 		offset BRANCH
 2144 1093 B8FFFFFF 		offset N1
 2145 1097 6EF4FFFF 	N2:	offset DROP
 2146 109b C9F3FFFF 		offset FromR
 2147 109f C0F2FFFF 		offset ZBranch
 2148 10a3 08000000 		offset N3
 2149 10a7 EFF7FFFF 		offset DMINUS
 2150 10ab 9F020000 	N3:	offset SemiS
 2151              	
 2152              	 #	: SPACES		( a -- )
 2153              	 #	  0 MAX -DUP 0BRANCH SPACES1
 2154              	 #	  0 (DO)
 2155              	 #	LABEL SPACES2
 2156              	 #	      SPACE
 2157              	 #	  (LOOP) SPACES2
 2158              	 #	LABEL SPACES1
 2159              	 #	;
 2160              	 #
 2161              	 #	Prints the specified number of spaces on the console.
 2162              	
 2163 10af A6535041 		colon "SPACES","SPACES","NUMBER"
 2163      4345534E 
 2163      FFFFFF5A 
 2163      F2FFFF
 2164 10be 780C0000 		offset Zero
 2165 10c2 A7F6FFFF 		offset MAX
 2166 10c6 86F4FFFF 		offset MinusDup
 2167 10ca 95F2FFFF 		offset ZBranch
 2168 10ce 18000000 		offset Spaces1
 2169 10d2 640C0000 		offset Zero
 2170 10d6 D0F2FFFF 		offset PDo
 2171 10da 64FCFFFF 	Spaces2: offset SPACE
 2172 10de 98F2FFFF 		offset PLoop
 2173 10e2 F8FFFFFF 		offset Spaces2
 2174 10e6 64020000 	Spaces1: offset SemiS
 2175              	
 2176              	 #	: <#		( -- )
 2177              	 #	  PAD HLD !
 2178              	 #	;
 2179              	 #
 2180              	 #	This word initializes variables used by the formatted output words.
 2181              	 #	Basically, it points HLD at the end of a region following the end
 2182              	 #	of the dictionary. As formatted output is generated, it moves towards
 2183              	 #	the dictionary.
 2184              	
 2185 10ea A23C23C2 		colon "LessHash","<#","SPACES"
 2185      FFFFFF23 
 2185      F2FFFF
 2186 10f5 330C0000 		offset PAD		# Get address of end of scratchpad
 2187 10f9 FE0B0000 		offset HLD		# Initialize HLD
 2188 10fd 2AF9FFFF 		offset Store
GAS LISTING nv32forth.s 			page 45


 2189 1101 49020000 		offset SemiS
 2190              	
 2191              	 #	: #>		( d.hi d.lo -- addr count )
 2192              	 #	  DROP DROP 	( d.hi d.lo -- )
 2193              	 #	  HLD @ 	( -- addr )
 2194              	 #	  PAD OVER -	( -- addr count )
 2195              	 #	;
 2196              	 #
 2197              	 #	This word ends formatted numeric output. It drops the double-precision
 2198              	 #	number from the math stack and returns the address and size of the
 2199              	 #	formatted output.
 2200              	
 2201 1105 A2233EE2 		colon "HashGreater","#>","LessHash"
 2201      FFFFFF08 
 2201      F2FFFF
 2202 1110 F5F3FFFF 		offset DROP
 2203 1114 F1F3FFFF 		offset DROP
 2204 1118 DF0B0000 		offset HLD
 2205 111c D3F8FFFF 		offset Fetch
 2206 1120 080C0000 		offset PAD
 2207 1124 BDF3FFFF 		offset OVER
 2208 1128 5FF4FFFF 		offset Subtract
 2209 112c 1E020000 		offset SemiS
 2210              	
 2211              	 #	: SIGN		( d.hi d.lo -- d.hi d.lo )
 2212              	 #	  ROT 0< 	( d.hi d.lo -- d.hi d.lo 1 <if negative> )
 2213              	 #	  0BRANCH SIGN1	( -- d.hi d.lo )
 2214              	 #	  LIT '-' HOLD	( stash the minus sign )
 2215              	 #	LABEL SIGN1
 2216              	 #	;
 2217              	 #
 2218              	 #	This word stuffs a '-' into the formatted numeric string if the
 2219              	 #	number being converted is negative.
 2220              	
 2221 1130 A4534947 		colon "SIGN","SIGN","HashGreater"
 2221      4ED0FFFF 
 2221      FFDBF1FF 
 2221      FF
 2222 113d 83F3FFFF 		offset ROT
 2223 1141 E0F4FFFF 		offset ZLess
 2224 1145 1AF2FFFF 		offset ZBranch
 2225 1149 10000000 		offset Sign1
 2226 114d F6F9FFFF 		literal 0x2d		# <^A/-/>
 2226      2D000000 
 2227 1155 06FEFFFF 		offset HOLD
 2228 1159 F1010000 	Sign1:	offset SemiS
 2229              	
 2230              	 #	: #		( d1 -- d2 )
 2231              	 #	  BASE @ 		( d1 -- d1 base )
 2232              	 #	  M/MOD 		( -- remainder d1/base.hi d1/base.lo )
 2233              	 #	  ROT 			( -- d1/base remainder )
 2234              	 #	  LIT 9 OVER		( -- d1/base remainder 9 remainder ) 
 2235              	 #	  < 			( -- d1/base remainder 1 <if remainder < 9> )
 2236              	 #	0BRANCH #1		( -- d1/base remainder )
 2237              	 #	  LIT 7 +		( -- d1/base remainder+7 )
 2238              	 #				( 7 is offset to make 'A' come after '9' )
 2239              	 #	LABEL #1
GAS LISTING nv32forth.s 			page 46


 2240              	 #	  LIT '0' + 		( -- d1/base remainder+'0' )
 2241              	 #	  HOLD			( -- d1/base )
 2242              	 #	;
 2243              	 #
 2244              	 #	This word generates the next digit from a double-length number 
 2245              	 #	on the top of the math stack. The result is the original double-length
 2246              	 #	number divied by the current base.
 2247              	
 2248 115d A123D1FF 		colon "Hash","#","SIGN"
 2248      FFFFB1F1 
 2248      FFFF
 2249 1167 600B0000 		offset BASE
 2250 116b 84F8FFFF 		offset Fetch
 2251 116f 4EF8FFFF 		offset MSlashMod
 2252 1173 4DF3FFFF 		offset ROT
 2253 1177 CCF9FFFF 		literal 9
 2253      09000000 
 2254 117f 62F3FFFF 		offset OVER
 2255 1183 13F4FFFF 		offset Less
 2256 1187 D8F1FFFF 		offset ZBranch
 2257 118b 10000000 		offset Hash1
 2258 118f B4F9FFFF 		literal 7
 2258      07000000 
 2259 1197 F9F4FFFF 		offset Plus
 2260 119b A8F9FFFF 	Hash1:	literal 0x30		# <^A/0/>
 2260      30000000 
 2261 11a3 EDF4FFFF 		offset Plus
 2262 11a7 B4FDFFFF 		offset HOLD
 2263 11ab 9F010000 		offset SemiS
 2264              	
 2265              	 #	: #S
 2266              	 #	LABEL #S1
 2267              	 #	  # 2DUP OR 0= ZBRANCH #S1
 2268              	 #	;
 2269              	 #
 2270              	 #	This word generates digits until the number being converted has
 2271              	 #	gone to zero.
 2272              	
 2273 11af A22353AB 		colon "HashS","#S","Hash"
 2273      FFFFFF5E 
 2273      F1FFFF
 2274 11ba A9FFFFFF 	HashS1:	offset Hash
 2275 11be 58F3FFFF 		offset TwoDUP
 2276 11c2 FFF3FFFF 		offset OR
 2277 11c6 43F4FFFF 		offset ZEq
 2278 11ca 95F1FFFF 		offset ZBranch
 2279 11ce ECFFFFFF 		offset HashS1
 2280 11d2 78010000 		offset SemiS
 2281              	
 2282              	 #	: D.R		( d.lo d.hi n -- )
 2283              	 #	  >R SWAP	( d.lo d.hi n -- d.hi d.lo d.hi )
 2284              	 #	  OVER DABS	( -- d.hi |d.lo d.hi| )
 2285              	 # 	  <# #S 	( -- d.hi )
 2286              	 #	  SIGN #> 	( -- pad count )
 2287              	 #	  R> OVER 	( -- pad count n count )
 2288              	 #	  - SPACES 	( -- pad count )
 2289              	 #	  TYPE		( -- )
GAS LISTING nv32forth.s 			page 47


 2290              	 #	;
 2291              	 #
 2292              	 #	This word displays the double-precision number d in the current
 2293              	 #	base in an n character field.
 2294              	
 2295 11d6 A3442E52 		colon "DDotR","D.R","HashS"
 2295      D5FFFFFF 
 2295      36F1FFFF 
 2296 11e2 72F2FFFF 		offset ToR
 2297 11e6 C0F2FFFF 		offset SWAP
 2298 11ea F7F2FFFF 		offset OVER
 2299 11ee E6F6FFFF 		offset DABS
 2300 11f2 FFFEFFFF 		offset LessHash
 2301 11f6 C0FFFFFF 		offset HashS
 2302 11fa 3FFFFFFF 		offset SIGN
 2303 11fe 0EFFFFFF 		offset HashGreater
 2304 1202 62F2FFFF 		offset FromR
 2305 1206 DBF2FFFF 		offset OVER
 2306 120a 7DF3FFFF 		offset Subtract
 2307 120e ACFEFFFF 		offset SPACES
 2308 1212 D5FBFFFF 		offset TYPE
 2309 1216 34010000 		offset SemiS
 2310              	
 2311              	 #	: .R		( a n -- )
 2312              	 #	  >R S->D R> D.R
 2313              	 #	;
 2314              	 #
 2315              	 #	This word prints the number a in an n character field. It does this
 2316              	 #	by sign-extending a and then printing the resulting double-precision
 2317              	 #	number using D.R.
 2318              	
 2319 121a A22E52B9 		colon "DotR",".R","DDotR"
 2319      FFFFFFF3 
 2319      F0FFFF
 2320 1225 2FF2FFFF 		offset ToR
 2321 1229 FDF6FFFF 		offset SignExtend
 2322 122d 37F2FFFF 		offset FromR
 2323 1231 ADFFFFFF 		offset DDotR
 2324 1235 15010000 		offset SemiS
 2325              	
 2326              	 #	: D.
 2327              	 #	  0 D.R SPACE
 2328              	 #	;
 2329              	 #
 2330              	 #	This word displays a double-precision number.
 2331              	
 2332 1239 A2442EDE 		colon "DDot","D.","DotR"
 2332      FFFFFFD4 
 2332      F0FFFF
 2333 1244 F20A0000 		offset Zero
 2334 1248 96FFFFFF 		offset DDotR
 2335 124c F2FAFFFF 		offset SPACE
 2336 1250 FA000000 		offset SemiS
 2337              	
 2338              	 #	: .		( a -- )
 2339              	 #	  S->D D.
 2340              	 #	;
GAS LISTING nv32forth.s 			page 48


 2341              	 #
 2342              	 #	This word prints the single-precision number on top of the math
 2343              	 #	stack. It does this by sign-extending the number to a double-length
 2344              	 #	integer and printing the resulting double-length integer.
 2345              	
 2346 1254 A12EE3FF 		colon "Dot",".","DDot"
 2346      FFFFBAF0 
 2346      FFFF
 2347 125e C8F6FFFF 		offset SignExtend	# ( a -- s.a a )
 2348 1262 DEFFFFFF 		offset DDot		# ( s.a a -- ) 		Print it
 2349 1266 E4000000 		offset SemiS		# 			We're done
 2350              	
 2351              	 #	: ?		( a -- )
 2352              	 #	  @ .
 2353              	 #	;
 2354              	 #
 2355              	 #	This word displays what is in memory at the location addressed by the
 2356              	 #	top of stack.
 2357              	
 2358 126a A13FE8FF 		colon "Question","?","Dot"
 2358      FFFFA4F0 
 2358      FFFF
 2359 1274 7BF7FFFF 		offset Fetch
 2360 1278 E2FFFFFF 		offset Dot
 2361 127c CE000000 		offset SemiS
 2362              	
 2363              	 #	: U.
 2364              	 #	  0 D.
 2365              	 #	;
 2366              	 #
 2367              	 #	This word displays an unsigned single-precision number. It does this
 2368              	 #	by zero-extending the number to double-precision and then displaying
 2369              	 #	the double-precision result.
 2370              	
 2371 1280 A2552EE7 		colon "UDot","U.","Question"
 2371      FFFFFF8D 
 2371      F0FFFF
 2372 128b AB0A0000 		offset Zero
 2373 128f B1FFFFFF 		offset DDot
 2374 1293 B7000000 		offset SemiS
 2375              	
 2376              	 #	: expect		( buffer maxsize -- )
 2377              	 #
 2378              	 #	This procedure reads a line into the specified buffer.
 2379              	 #
 2380              	 #	This is really primitive. The only non-printing characters it knows
 2381              	 #	about are BS, DEL, and CR. All other whitespace is ignored.
 2382              	 #
 2383              	 #	If you have typed past the end of the buffer, the new character is
 2384              	 #	ignored; it is not echoed so that you will know you've done something
 2385              	 #	wrong.
 2386              	 #
 2387              	 #	Input ends when you press CR. At that time, a CR/LF is echoed and
 2388              	 #	EXPECT exits.
 2389              	 #
 2390              	 #	If you press BS or DEL and you aren't at the beginning of the buffer,
 2391              	 #	BS/space/BS will be echoed and EXPECT will back up one position in
GAS LISTING nv32forth.s 			page 49


 2392              	 #	the buffer.
 2393              	
 2394 1297 A6455850 		code "EXPECT","EXPECT","UDot"
 2394      454354E2 
 2394      FFFFFF04 
 2394      000000
 2395 12a6 D08759   		movl (r7)+,r9		# Maximum buffer size to R9
 2396 12a9 D08758   		movl (r7)+,r8		# Buffer start address to R8
 2397 12ac C05859   		addl2 r8,r9		# Address of location after buffer to R9
 2398 12af D05856   		movl r8,r6		# Current address to R6
 2399              	
 2400              	Expect1:
 2401 12b2 3079ED   		bsbw ConIn		# Get a key
 2402 12b5 8A8F8050 		bicb2 $0x80,r0		# Just to be sure
 2403 12b9 910D50   		cmpb $13,r0		# Is it a <CR>?
 2404 12bc 1338     		beql Expect_CR		# If so, go
 2405 12be 910850   		cmpb $8,r0		# Is it a <BS>
 2406 12c1 1318     		beql Expect_BS		# If so, go
 2407 12c3 918F7F50 		cmpb $127,r0
 2408 12c7 1312     		beql Expect_BS
 2409 12c9 912050   		cmpb $32,r0		# Is it other whitespace?
 2410 12cc 14E4     		bgtr Expect1		# If so, we don't know how to deal with it,
 2411              					# so ignore it and hope it'll go away.
 2412              	
 2413              	 #	Received a printable character
 2414              	
 2415 12ce D15659   		cmpl r6,r9		# Is the buffer full?
 2416 12d1 13DF     		beql Expect1		# If so, ignore the character
 2417              	
 2418 12d3 905086   		movb r0,(r6)+		# Otherwise, store the buffer
 2419 12d6 30F1F9   		bsbw FConOut		# Echo it
 2420 12d9 11D7     		brb Expect1		# And wait for another
 2421              	
 2422              	 #	Received a backspace
 2423              	
 2424              	Expect_BS:
 2425 12db D15856   		cmpl r8,r6		# Is the buffer empty?
 2426 12de 13D2     		beql Expect1		# If so, ignore it
 2427 12e0 D756     		decl r6			# Subtract the character from the buffer
 2428 12e2 9A0850   		movzbl $8,r0		# And from the screen
 2429 12e5 30E2F9   		bsbw FConOut
 2430 12e8 9A2050   		movzbl $32,r0
 2431 12eb 30DCF9   		bsbw FConOut
 2432 12ee 9A0850   		movzbl $8,r0
 2433 12f1 30D6F9   		bsbw FConOut
 2434 12f4 11BC     		brb Expect1		# And wait for another
 2435              	
 2436              	 #	Received a CR
 2437              	
 2438              	Expect_CR:
 2439 12f6 9A0D50   		movzbl $13,r0		# Echo for the user
 2440 12f9 30CEF9   		bsbw FConOut
 2441 12fc 9A0A50   		movzbl $10,r0
 2442 12ff 30C8F9   		bsbw FConOut
 2443 1302 915659   		cmpb r6,r9		# Room for null terminator?
 2444 1305 1302     		beql Expect_Exit	# Nope; just leave
 2445 1307 9466     		clrb (r6)		# otherwise, terminate the booger
GAS LISTING nv32forth.s 			page 50


 2446              	Expect_Exit:
 2447 1309 176B     		jmp (r11)		# Back to ForthOMat
 2448              	
 2449              	 #	: ID.			( NFA -- <PRINT ID OF A WORD> )
 2450              	 #	  dup @ lit 0x1f and 	( nfa wordlength )
 2451              	 #	  swap 1+ swap		( nfa+1 wordlength )
 2452              	 #	  type space
 2453              	 #	;
 2454              	 #
 2455              	 #	I've redone this one because I think the original code was
 2456              	 #	idiotic; it calculated the string length by subtracting LFA from
 2457              	 #	NFA (after first taking a detour through PFA because that's what
 2458              	 #	LFA expects) rather than just fetching the damn thing from the
 2459              	 #	NFA where it started! The guy also seems to want to lay down blanks
 2460              	 #	on top of memory he's just gonna overwrite anyway (see WORD).
 2461              	 #
 2462              	 #	This word prints the name field of a word. This is primarily used
 2463              	 #	by VLIST to display the contents of the dictionary.
 2464              	
 2465 130b A349442E 		colon "IDDot","ID.","EXPECT"
 2465      88FFFFFF 
 2465      01F0FFFF 
 2466 1317 DCF1FFFF 		offset DUP		# Don't want to lose nfa when we fetch
 2467 131b D4F6FFFF 		offset Fetch
 2468 131f 24F8FFFF 		literal 0x1f
 2468      1F000000 
 2469 1327 87F2FFFF 		offset AND
 2470 132b 7BF1FFFF 		offset SWAP
 2471 132f 95F3FFFF 		offset OnePlus
 2472 1333 73F1FFFF 		offset SWAP
 2473 1337 B0FAFFFF 		offset TYPE
 2474 133b 03FAFFFF 		offset SPACE
 2475 133f 0B000000 		offset SemiS
 2476              	
 2477              	 #	;S: Loads IP from return stack
 2478              	 #
 2479              	 #	This procedure ends a FORTH word; it is the runtime action performed
 2480              	 #	by ;. It copies a value from the return stack into IP (R10) and resumes
 2481              	 #	execution at the new IP. The IP was originally stashed by DoCol when 
 2482              	 #	the word was entered. 
 2483              	 #
 2484              	 #	; refers to this word during compilation.
 2485              	
 2486 1343 A23B53C5 		code "SemiS","\x3bS","IDDot"	# ";S"
 2486      FFFFFF04 
 2486      000000
 2487 134e D08E5A   		movl (sp)+,r10
 2488 1351 176B     		jmp (r11)
 2489              	
 2490              	 #	: [		( BEGIN EXECUTING )
 2491              	 #	  0 STATE !
 2492              	 #	;*
 2493              	 #
 2494              	 #	This word takes the FORTH system out of compiling mode.
 2495              	
 2496 1353 E15BEEFF 		colon "LBracket","[","SemiS",Immediate
 2496      FFFFBBEF 
GAS LISTING nv32forth.s 			page 51


 2496      FFFF
 2497 135d D9090000 		offset Zero
 2498 1361 55090000 		offset STATE
 2499 1365 C2F6FFFF 		offset Store
 2500 1369 E1FFFFFF 		offset SemiS
 2501              	
 2502              	 #	: ]		( END EXECUTING )
 2503              	 #	  LIT 0xC0 State !
 2504              	 #	;*
 2505              	 #
 2506              	 #	This word puts the FORTH system in compiling mode.
 2507              	
 2508 136d E15DD4FF 		colon "RBracket","]","SemiS",Immediate
 2508      FFFFA1EF 
 2508      FFFF
 2509 1377 CCF7FFFF 		literal 0xc0
 2509      C0000000 
 2510 137f 37090000 		offset STATE
 2511 1383 A4F6FFFF 		offset Store
 2512 1387 C3FFFFFF 		offset SemiS
 2513              	
 2514              	 #	: :		( DEFINE A WORD )
 2515              	 #	  ?EXEC
 2516              	 #	  !CSP
 2517              	 #	  CREATE ]	( MAKE THE WORD HEADER AND BEGIN COMPILING )
 2518              	 #	  (;CODE) DOCOL
 2519              	 #	;*
 2520              	 #
 2521              	 #	This word makes a new FORTH word; it makes an entry in the
 2522              	 #	dictionary with a CFA that points to DoCol, the code segment
 2523              	 #	that knows how to enter a FORTH word.
 2524              	 #
 2525              	 #	Unfortunately, DoCol doesn't show up in the dictionary, so you
 2526              	 #	can't define your own word equivalent to :...
 2527              	 #
 2528              	 #	I'm not convinced : has to be immediate...
 2529              	
 2530 138b E13AE0FF 		colon "Colon",":","RBracket",Immediate
 2530      FFFF83EF 
 2530      FFFF
 2531 1395 93050000 		offset QExec
 2532 1399 D4F1FFFF 		offset StoreCSP
 2533 139d 5B020000 		offset CREATE
 2534 13a1 D2FFFFFF 		offset RBracket
 2535 13a5 DE000000 		offset PSemiCode
 2536 13a9 6BEFFFFF 		offset DoCol
 2537 13ad 9DFFFFFF 		offset SemiS
 2538              	
 2539              	 #	: ;		( END A DEFINITION )
 2540              	 #	  ?CSP		( CHECK THAT WE'RE DONE )
 2541              	 #	  COMPILE ;S	( PLACE ;S AT THE END )
 2542              	 #	  SMUDGE [	( MAKE THE WORD FINDABLE AND BEGIN INTERPRETING
 2543              	 #	;*
 2544              	 #
 2545              	 #	This word finishes the definition of a word started with :. It
 2546              	 #	appends the address of ;S, the code segment that knows how to
 2547              	 #	exit a FORTH word, to the current word and takes the FORTH system
GAS LISTING nv32forth.s 			page 52


 2548              	 #	back to interpreting mode.
 2549              	
 2550 13b1 E13BD8FF 		colon "Semicolon","\x3b","Colon",Immediate	# "\;",Immediate
 2550      FFFF5DEF 
 2550      FFFF
 2551 13bb B5050000 		offset QCSP
 2552 13bf 9D020000 		offset COMPILE
 2553 13c3 87FFFFFF 		offset SemiS
 2554 13c7 F3010000 		offset SMUDGE
 2555 13cb 8EFFFFFF 		offset LBracket
 2556 13cf 7BFFFFFF 		offset SemiS
 2557              	
 2558              	 #	: CONSTANT
 2559              	 #	  CREATE SMUDGE ,
 2560              	 #	  (;CODE) DOCON
 2561              	 #	;
 2562              	 #
 2563              	 #	This word creates a constant. A constant is a word that, when executed,
 2564              	 #	puts the longword in its Parameter Field onto the math stack. This word
 2565              	 #	creates a new word, points its CFA at the segment of code that knows
 2566              	 #	how to do a constant (DoCon), and compiles the item on top of the math
 2567              	 #	stack into the word's parameter field.
 2568              	 #
 2569              	 #	DoCon doesn't show up in the dictionary, so you can't write your own
 2570              	 #	word equivalent to CONSTANT...
 2571              	
 2572 13d3 A8434F4E 		colon "CONSTANT","CONSTANT","Semicolon"
 2572      5354414E 
 2572      54D5FFFF 
 2572      FF34EFFF 
 2572      FF
 2573 13e4 14020000 		offset CREATE
 2574 13e8 D2010000 		offset SMUDGE
 2575 13ec 28F8FFFF 		offset Comma
 2576 13f0 93000000 		offset PSemiCode
 2577 13f4 29EFFFFF 		offset DoCon
 2578 13f8 52FFFFFF 		offset SemiS
 2579              	
 2580              	 #	: VARIABLE
 2581              	 #	  CONSTANT
 2582              	 #	  (;CODE) DOVAR
 2583              	 #	;
 2584              	 #
 2585              	 #	This word creates a variable in the dictionary. A variable is
 2586              	 #	similar to a constant, except that it places the address of its
 2587              	 #	parameter field on the math stack instead of the longword stored
 2588              	 #	there. This word creates the variable by first creating a constant
 2589              	 #	and then changing the CFA of the last word created to point to
 2590              	 #	DoVar, the code that knows how to do a variable.
 2591              	 #
 2592              	 #	Unfortunately, DoVar doesn't show up in the dictionary, so you 
 2593              	 #	can't write your own code equivalent to VARIABLE...
 2594              	
 2595 13fc A8564152 		colon "VARIABLE","VARIABLE","CONSTANT"
 2595      4941424C 
 2595      45CEFFFF 
 2595      FF0BEFFF 
GAS LISTING nv32forth.s 			page 53


 2595      FF
 2596 140d D3FFFFFF 		offset CONSTANT
 2597 1411 72000000 		offset PSemiCode
 2598 1415 0EEFFFFF 		offset DoVar
 2599 1419 31FFFFFF 		offset SemiS
 2600              	
 2601              	 #	: CODE
 2602              	 #	  CREATE 4 HERE 4 - W!
 2603              	 #	;
 2604              	 #
 2605              	 #	This word starts the definition of a word containing machine code.
 2606              	 #	It does whatever : does, then mutilates the CFA of the word to
 2607              	 #	point to the word's PFA; that is, it modifies the word to indicate
 2608              	 #	that the code with knows how to execute the word is in the word's
 2609              	 #	PFA.
 2610              	 #
 2611              	 #	$$$
 2612              	
 2613 141d A4434F44 		colon "CODE","CODE","VARIABLE"
 2613      45DAFFFF 
 2613      FFEEEEFF 
 2613      FF
 2614 142a CE010000 		offset CREATE
 2615 142e 15F7FFFF 		literal 4		# Offset to code that knows how to do the word
 2615      04000000 
 2616 1436 A6F7FFFF 		offset HERE		# Here is now the address of the PFA
 2617 143a 09F7FFFF 		literal 4		# Form address of CFA
 2617      04000000 
 2618 1442 45F1FFFF 		offset Subtract
 2619 1446 E1F5FFFF 		offset Store
 2620 144a 00FFFFFF 		offset SemiS
 2621              	
 2622              	 #	: EDOC
 2623              	 #	  ?csp
 2624              	 #	  lit 'JMP (R11)' W, smudge [
 2625              	 #	;*
 2626              	 #
 2627              	 #	This word ends the definition of a word containing machine code.
 2628              	 #	It puts the end instruction ( JMP (R11) ) at the end of the word
 2629              	 #	and returns the FORTH system to interpretation mode.
 2630              	 #
 2631              	 #	Since EDOC properly terminates a machine code word, the minimal
 2632              	 #	machine code word is:
 2633              	 #
 2634              	 #	CODE BOOGER EDOC
 2635              	 #
 2636              	 #	$$$
 2637              	
 2638 144e E445444F 		colon "EDOC","EDOC","CODE",Immediate
 2638      43CAFFFF 
 2638      FFBDEEFF 
 2638      FF
 2639 145b 15050000 		offset QCSP
 2640 145f E4F6FFFF 		offset LIT
 2641 1463 176B     		jmp (r11)		# We want the instruction JMP (R11)
 2642 1465 0000     		.WORD 0			# LITERAL has to be a longword
 2643 1467 D0F7FFFF 		offset WComma
GAS LISTING nv32forth.s 			page 54


 2644 146b EEFEFFFF 		offset LBracket
 2645 146f 4B010000 		offset SMUDGE
 2646 1473 D7FEFFFF 		offset SemiS
 2647              	
 2648              	 #	: (;CODE)	( fetch the word after (;code), relocate, and
 2649              	 #			  toss on the CFA of the current word
 2650              	 #	  R 		( Address of offset )
 2651              	 #	  dup @ + 	( Fetch it and form absolute address )
 2652              	 #	  LATEST PFA CFA ( Address where we want to store it )
 2653              	 #	  swap over	( -- addr what addr )
 2654              	 #	  - swap !	( Form offset AND store )
 2655              	 #	  r> 4 + >r	( skip the offset )
 2656              	 #	;
 2657              	 #
 2658              	 #	This word is followed by a word parameter. The word parameter specifies
 2659              	 #	the address of the code that is to be executed when the latest word
 2660              	 #	defined is entered; the parameter is, of course, a relative offset
 2661              	 #	to the code.
 2662              	
 2663 1477 A7283B43 		colon "PSemiCode","(\x3b\CODE)","EDOC"	# "(;CODE)"
 2663      4F444529 
 2663      CFFFFFFF 
 2663      91EEFFFF 
 2664 1487 ECEFFFFF 		offset R
 2665 148b 68F0FFFF 		offset DUP
 2666 148f 60F5FFFF 		offset Fetch
 2667 1493 FDF1FFFF 		offset Plus
 2668 1497 46010000 		offset LATEST
 2669 149b E8000000 		offset PFA
 2670 149f 94000000 		offset CFA
 2671 14a3 03F0FFFF 		offset SWAP
 2672 14a7 3AF0FFFF 		offset OVER
 2673 14ab DCF0FFFF 		offset Subtract
 2674 14af F7EFFFFF 		offset SWAP
 2675 14b3 74F5FFFF 		offset Store
 2676 14b7 ADEFFFFF 		offset FromR
 2677 14bb 88F6FFFF 		literal 4
 2677      04000000 
 2678 14c3 CDF1FFFF 		offset Plus
 2679 14c7 8DEFFFFF 		offset ToR
 2680 14cb 7FFEFFFF 		offset SemiS
 2681              	
 2682              	 #	: -FIND			( -- pfa length 1 <if found> )
 2683              	 #				( -- 0 <if not found> )
 2684              	 #	  BL WORD		append the word we're searchin' for to
 2685              	 #				the dictionary
 2686              	 #	  HERE LATEST (FIND)
 2687              	 #	;
 2688              	 #
 2689              	 #	This word searches the dictionary for the word at the end of the
 2690              	 #	dictionary; WORD copies a word from TIB to the end of the
 2691              	 #	dictionary. If the word is not found in the dictionary, 0 is
 2692              	 #	placed on the math stack. Otherwise, the parameter field address
 2693              	 #	of the found word, the length byte from the found word's name
 2694              	 #	field, and a 1 are placed on the stack.
 2695              	 #
 2696              	 #	INTERPRET depends on the entire length byte from the found word
GAS LISTING nv32forth.s 			page 55


 2697              	 #	being pushed onto the stack rather than just the length of the word.
 2698              	 #	The length byte of a FORTH word includes some flags, most importantly
 2699              	 #	for this discussion the immediate flag. INTERPRET compares STATE
 2700              	 #	against the returned length byte to determine whether to compile
 2701              	 #	or execute the found word; if the actual length byte is not returned,
 2702              	 #	INTERPRET will never decide to execute immediate words during
 2703              	 #	compilation.
 2704              	
 2705 14cf A52D4649 		colon "MinusFind","-FIND","PSemiCode"
 2705      4E44A2FF 
 2705      FFFF3BEE 
 2705      FFFF
 2706 14dd 3B080000 		offset BL
 2707 14e1 C3020000 		offset WORD
 2708 14e5 F7F6FFFF 		offset HERE
 2709 14e9 F4000000 		offset LATEST
 2710 14ed 43030000 		offset PFind
 2711 14f1 59FEFFFF 		offset SemiS
 2712              	
 2713              	 #	: (		( COMMENT )
 2714              	 #	  LIT ')'	( CLOSING PAREN )
 2715              	 #	  WORD
 2716              	 #	;*
 2717              	 #
 2718              	 #	This word ignores a comment. Bytes are collected at the end of the
 2719              	 #	dictionary until the matching close paren. These bytes are then
 2720              	 #	ignored.
 2721              	
 2722 14f5 E128D8FF 		colon "Comment","(","MinusFind",Immediate
 2722      FFFF19EE 
 2722      FFFF
 2723 14ff 44F6FFFF 		literal 0x29		# <^A/)/>
 2723      29000000 
 2724 1507 9D020000 		offset WORD
 2725 150b 3FFEFFFF 		offset SemiS
 2726              	
 2727              	 #	: lfa			( pfa -- lfa )
 2728              	 #	  8 -
 2729              	 #	;
 2730              	 # 
 2731              	 #	This word takes the mythical "parameter field address" and 
 2732              	 #	returns the link field address. The parameter field address is
 2733              	 #	the area after the first word of code; variables and constants
 2734              	 #	etc. store data after a code word that does the work expected
 2735              	 #	of a variable (fetching the address of the variable) or
 2736              	 #	constant (fetching the value of the constant).
 2737              	
 2738 150f A34C4641 		colon "LFA","LFA","Comment"
 2738      E2FFFFFF 
 2738      FDEDFFFF 
 2739 151b 28F6FFFF 		literal 8
 2739      08000000 
 2740 1523 64F0FFFF 		offset Subtract
 2741 1527 23FEFFFF 		offset SemiS
 2742              	
 2743              	 #	: cfa			( pfa -- cfa )
 2744              	 #	  4 -
GAS LISTING nv32forth.s 			page 56


 2745              	 #	;
 2746              	 #
 2747              	 #	This word takes the mythical "parameter field address" and
 2748              	 #	returns the address of the code field, the start of code for
 2749              	 #	the word.
 2750              	
 2751 152b A3434641 		colon "CFA","CFA","LFA"
 2751      E0FFFFFF 
 2751      E1EDFFFF 
 2752 1537 0CF6FFFF 		literal 4
 2752      04000000 
 2753 153f 48F0FFFF 		offset Subtract
 2754 1543 07FEFFFF 		offset SemiS
 2755              	
 2756              	 #	: nfa			( pfa -- nfa )
 2757              	 #	  lfa
 2758              	 #	label nfa1
 2759              	 #	  1- dup c@ lit 0x80 and 0branch nfa1
 2760              	 #	;
 2761              	 #
 2762              	 #	This word takes the mythical "parameter field address" and
 2763              	 #	returns the address of the name field; this is the first byte
 2764              	 #	of the word and contains the name length, smudge, and immediate
 2765              	 #	flags.
 2766              	 #
 2767              	 #	This word works by first backing up to the LFA (which immediately
 2768              	 #	follows the name field) and then searching backwards for a byte
 2769              	 #	with bit 7 set. This should be the length byte.
 2770              	
 2771 1547 A34E4641 		colon "NFA","NFA","CFA"
 2771      E0FFFFFF 
 2771      C5EDFFFF 
 2772 1553 C4FFFFFF 		offset LFA		# Take us to the link field address
 2773 1557 9BF1FFFF 	NFA1:	offset OneMinus		# Let's look at the previous byte
 2774 155b 98EFFFFF 		offset DUP		# (don't want to lose it when we fetch)
 2775 155f A1F4FFFF 		offset CFetch
 2776 1563 E0F5FFFF 		literal 0x80		# Is bit 7 set?
 2776      80000000 
 2777 156b 43F0FFFF 		offset AND
 2778 156f F0EDFFFF 		offset ZBranch		# If not, keep looking
 2779 1573 E4FFFFFF 		offset NFA1
 2780 1577 D3FDFFFF 		offset SemiS		# If so, we're done
 2781              	
 2782              	 #	: pfa		( nfa -- pfa )
 2783              	 #	  dup @
 2784              	 #	  lit 0x1f and +  ( take us to the lfa )
 2785              	 #	  lit 9 +	  ( skip lfa, cfa, and length byte )
 2786              	 #	;
 2787              	 #
 2788              	 #	This procedure finds the mythical "parameter field address" given
 2789              	 #	the name field address. It uses the length byte attached to the
 2790              	 #	name to skip the name and then bumps past the lfa and cfa.
 2791              	
 2792 157b A3504641 		colon "PFA","PFA","NFA"
 2792      C8FFFFFF 
 2792      91EDFFFF 
 2793 1587 6CEFFFFF 		offset DUP		# don't want to lose nfa when we fetch
GAS LISTING nv32forth.s 			page 57


 2794 158b 64F4FFFF 		offset Fetch		# get the name length
 2795 158f B4F5FFFF 		literal 0x1f		# strip off smudge, immediate, and findme
 2795      1F000000 
 2796 1597 17F0FFFF 		offset AND
 2797 159b F5F0FFFF 		offset Plus		# add it to the nfa
 2798 159f A4F5FFFF 		literal 9
 2798      09000000 
 2799 15a7 E9F0FFFF 		offset Plus		# skip the lfa, cfa, and length byte
 2800 15ab 9FFDFFFF 		offset SemiS
 2801              	
 2802              	 #	: SMUDGE		( TOGGLE COMPLETION BIT OF LATEST WORD )
 2803              	 #	  LATEST		( WHEN THIS BIT=1, WORD CAN'T BE FOUND )
 2804              	 #	  LIT 0x20 TOGGLE
 2805              	 #	;
 2806              	 #
 2807              	 #	This word toggles the "smudge" bit of the last word that was
 2808              	 #	compiled. Until smudge is cleared, the word can't be found.
 2809              	 #
 2810              	 #	Not that this is a useful feature; we don't always begin searching
 2811              	 #	with the latest word compiled and we always smudge a word when we're
 2812              	 #	done compiling it.
 2813              	
 2814 15af A6534D55 		colon "SMUDGE","SMUDGE","PFA"
 2814      444745C5 
 2814      FFFFFF5A 
 2814      EDFFFF
 2815 15be 1F000000 		offset LATEST
 2816 15c2 81F5FFFF 		literal 0x20
 2816      20000000 
 2817 15ca 2FF0FFFF 		offset TOGGLE
 2818 15ce 7CFDFFFF 		offset SemiS
 2819              	
 2820              	 #	: LATEST		( NFA OF LAST WORD DEFINED )
 2821              	 #	  CURRENT @ ;
 2822              	 #
 2823              	 #	This fetches the address of the current word being worked on.
 2824              	 #	Originally, it was some sort of "user" variable, so a double
 2825              	 #	fetch was needed. I've made it a normal variable, so we only
 2826              	 #	need a single fetch.
 2827              	
 2828 15d2 A64C4154 		colon "LATEST","LATEST","SMUDGE"
 2828      455354D6 
 2828      FFFFFF37 
 2828      EDFFFF
 2829 15e1 C3060000 		offset CURRENT
 2830 15e5 0AF4FFFF 		offset Fetch
 2831 15e9 61FDFFFF 		offset SemiS
 2832              	
 2833              	 #	: create		( -- pfa )
 2834              	 #	  bl word		( tack word on end of dictionary )
 2835              	 #	  here dup 		( here will change after allot )
 2836              	 #	  c@ 1+ allot		( allocate space for word & length )
 2837              	 #	  dup			( still need old here to update current )
 2838              	 #	  lit 0xa0 toggle	( set top bit in first char & smudge )
 2839              	 #	  latest o,		( store address of previous word )
 2840              	 #	  current !		( update current word pointer )
 2841              	 #	  (;code) dovar		( originally, word will look like variable )
GAS LISTING nv32forth.s 			page 58


 2842              	 #	  4 allot		( allocate space taken by CFA )
 2843              	 #	;
 2844              	 #
 2845              	 #	This word builds a header for a word. It points the CFA at the
 2846              	 #	code that knows how to execute a variable; this means that,
 2847              	 #	unless the CFA is adjusted, the word will act like a variable. A
 2848              	 #	compiling word should fill in the CFA of the word with the
 2849              	 #	address of a machine-code routine that knows how to enter
 2850              	 #	the word.
 2851              	 #
 2852              	 #	Oh yeah; although the word behaves like a variable, no space is
 2853              	 #	allocated for the PFA.
 2854              	
 2855 15ed A6435245 		colon "CREATE","CREATE","LATEST"
 2855      415445DE 
 2855      FFFFFF1C 
 2855      EDFFFF
 2856 15fc 1C070000 		offset BL
 2857 1600 A4010000 		offset WORD
 2858 1604 D8F5FFFF 		offset HERE
 2859 1608 EBEEFFFF 		offset DUP		# here here
 2860 160c F4F3FFFF 		offset CFetch		# here length (smudge not set yet)
 2861 1610 B4F0FFFF 		offset OnePlus		# here length+1 (account for length byte)
 2862 1614 E2F5FFFF 		offset ALLOT		# here (note, real here has changed; old
 2863              					#       here is still on stack)
 2864 1618 DBEEFFFF 		offset DUP		# here here 
 2865 161c 27F5FFFF 		literal 0xa0		# here here 0xa0
 2865      A0000000 
 2866 1624 D5EFFFFF 		offset TOGGLE		# here (smudge now set)
 2867 1628 B5FFFFFF 		offset LATEST		# here latest
 2868 162c 49F6FFFF 		offset OComma		# here
 2869 1630 74060000 		offset CURRENT		# here current
 2870 1634 F3F3FFFF 		offset Store		#
 2871 1638 4BFEFFFF 		offset PSemiCode
 2872 163c E7ECFFFF 		offset DoVar
 2873 1640 03F5FFFF 		literal 4
 2873      04000000 
 2874 1648 AEF5FFFF 		offset ALLOT
 2875 164c FEFCFFFF 		offset SemiS
 2876              	
 2877              	 #	: compile	( fetch the word following and compile it onto the
 2878              	 #			  end of the dictionary )
 2879              	 #	  R 		( Address of offset )
 2880              	 #	  dup @ + 	( Fetch it and form absolute address )
 2881              	 #	  o,
 2882              	 #	  r> 4 + >r	( skip the offset )
 2883              	 #	;
 2884              	 #
 2885              	 #	This word takes the offset immediately following a reference to it
 2886              	 #	and compiles a reference to that word at the end of the
 2887              	 #	dictionary. The reference is (of course) a word offset, so it has
 2888              	 #	to be first un-PICced to get the address being referenced and then
 2889              	 #	rePICced when it's compiled into the new word.
 2890              	
 2891 1650 A7434F4D 		colon "COMPILE","COMPILE","CREATE"
 2891      50494C45 
 2891      95FFFFFF 
GAS LISTING nv32forth.s 			page 59


 2891      B8ECFFFF 
 2892 1660 13EEFFFF 		offset R
 2893 1664 8FEEFFFF 		offset DUP
 2894 1668 87F3FFFF 		offset Fetch
 2895 166c 24F0FFFF 		offset Plus
 2896 1670 05F6FFFF 		offset OComma
 2897 1674 F0EDFFFF 		offset FromR
 2898 1678 CBF4FFFF 		literal 4
 2898      04000000 
 2899 1680 10F0FFFF 		offset Plus
 2900 1684 D0EDFFFF 		offset ToR
 2901 1688 C2FCFFFF 		offset SemiS
 2902              	
 2903              	 #	: [COMPILE]	( COMPILE THE NEXT WORD, EVEN IF IT'S IMMEDIATE )
 2904              	 #	  -FIND 0= 0 ?ERROR DROP CFA o,
 2905              	 #	;*
 2906              	 #
 2907              	 #	This word locates a word in the dictionary and compiles a reference
 2908              	 #	to the word into the word being built, conveniently ignoring the
 2909              	 #	IMMEDIATE bit; if you want to make a word that does something similar
 2910              	 #	to :, you can [COMPILE] : to make a reference to : inside your word.
 2911              	
 2912 168c A95B434F 		colon "BracketsCOMPILE","[COMPILE]","COMPILE"
 2912      4D50494C 
 2912      455DBAFF 
 2912      FFFF7AEC 
 2912      FFFF
 2913 169e 3BFEFFFF 		offset MinusFind
 2914 16a2 67EFFFFF 		offset ZEq
 2915 16a6 90060000 		offset Zero
 2916 16aa 2E020000 		offset QError
 2917 16ae 57EEFFFF 		offset DROP
 2918 16b2 81FEFFFF 		offset CFA
 2919 16b6 BFF5FFFF 		offset OComma
 2920 16ba 90FCFFFF 		offset SemiS
 2921              	
 2922              	 #	: IMMEDIATE	( MAKE MOST-RECENT WORD IMMEDIATE )
 2923              	 #	  LATEST LIT 0x40 TOGGLE
 2924              	 #	;
 2925              	 #
 2926              	 #	This word toggles the IMMEDIATE bit of the last word that was
 2927              	 #	compiled. If the IMMEDIATE bit is set, the word is executed during
 2928              	 #	compile mode instead of a reference to the word being compiled into
 2929              	 #	the word being built.
 2930              	
 2931 16be A9494D4D 		colon "IMMEDIATE","IMMEDIATE","BracketsCOMPILE"
 2931      45444941 
 2931      5445C4FF 
 2931      FFFF48EC 
 2931      FFFF
 2932 16d0 0DFFFFFF 		offset LATEST
 2933 16d4 6FF4FFFF 		literal 0x40
 2933      40000000 
 2934 16dc 1DEFFFFF 		offset TOGGLE
 2935 16e0 6AFCFFFF 		offset SemiS
 2936              	
 2937              	 #	: forget
GAS LISTING nv32forth.s 			page 60


 2938              	 #	  ' 		( find the word to forget: -- pfa )
 2939              	 #	  dup 		( pfa pfa )
 2940              	 #	  nfa 		( pfa nfa )
 2941              	 #	  dp !		( pfa )
 2942              	 #	  lfa 		( lfa )
 2943              	 #	  dup		( lfa lfa )
 2944              	 #	  @ +		( nfa of previous word )
 2945              	 #	  dup		( pfa nfa nfa )
 2946              	 #	  current !	( pfa nfa )
 2947              	 #	;
 2948              	 #
 2949              	 #	This word locates the named word in the dictionary and updates the
 2950              	 #	dictionary pointer and various other variables to believe that word
 2951              	 #	is the last word that was defined.
 2952              	 #
 2953              	 #	Please don't FORGET built-in words...
 2954              	
 2955 16e4 A6464F52 		colon "FORGET","FORGET","IMMEDIATE"
 2955      474554D3 
 2955      FFFFFF25 
 2955      ECFFFF
 2956 16f3 88000000 		offset Tick
 2957 16f7 FCEDFFFF 		offset DUP
 2958 16fb 54FEFFFF 		offset NFA
 2959 16ff 82050000 		offset DP
 2960 1703 24F3FFFF 		offset Store
 2961 1707 10FEFFFF 		offset LFA
 2962 170b E8EDFFFF 		offset DUP
 2963 170f E0F2FFFF 		offset Fetch
 2964 1713 7DEFFFFF 		offset Plus
 2965 1717 DCEDFFFF 		offset DUP
 2966 171b 89050000 		offset CURRENT
 2967 171f 08F3FFFF 		offset Store
 2968 1723 27FCFFFF 		offset SemiS
 2969              	
 2970              	 #	: vlist		( display the dictionary )
 2971              	 #	  latest	( nfa of last word in dictionary )
 2972              	 #	label vlist1
 2973              	 #	  dup id.	( display the name of this word )
 2974              	 #	  pfa lfa	( lfa )
 2975              	 #	  dup @		( lfa OffsetToPreviousWord )
 2976              	 #	  dup		( lfa offset offset )
 2977              	 #	  0branch vlist2 ( if offset is zero, we're done )
 2978              	 #	  +		( make offset to previous nfa )
 2979              	 #	  branch vlist1
 2980              	 #	label vlist2
 2981              	 #	  drop drop	( lost lfa and link of last word )
 2982              	 #	;
 2983              	 #
 2984              	 #	This word lists the contents of the dictionary in order from the
 2985              	 #	last word to the first word.
 2986              	
 2987 1727 A5564C49 		colon "VLIST","VLIST","FORGET"
 2987      5354B7FF 
 2987      FFFFE3EB 
 2987      FFFF
 2988 1735 A8FEFFFF 		offset LATEST	# ( nfa )		Start at the last word
GAS LISTING nv32forth.s 			page 61


 2989 1739 BAEDFFFF 	vlist1: offset DUP	# ( nfa nfa )
 2990 173d D6FBFFFF 		offset IDDot	# ( nfa )		Display its name
 2991 1741 42FEFFFF 		offset PFA	# ( pfa )
 2992 1745 D2FDFFFF 		offset LFA	# ( lfa )
 2993 1749 AAEDFFFF 		offset DUP	# ( lfa lfa )
 2994 174d A2F2FFFF 		offset Fetch	# ( lfa link )		Get link to previous word
 2995 1751 A2EDFFFF 		offset DUP	# ( lfa link link )
 2996 1755 0AECFFFF 		offset ZBranch	# ( lfa link )		If it's zero, we're done
 2997 1759 10000000 		offset vlist2
 2998 175d 33EFFFFF 		offset Plus	# ( lfa+link = nfa of previous word )
 2999 1761 E9EBFFFF 		offset BRANCH	#			Advance to next word
 3000 1765 D4FFFFFF 		offset vlist1
 3001 1769 9CEDFFFF 	vlist2:	offset DROP
 3002 176d 98EDFFFF 		offset DROP
 3003 1771 D9FBFFFF 		offset SemiS
 3004              	
 3005              	 #	: '		( -- pfa <if interpreting> )
 3006              	 #	  -FIND 0= 0 ?ERROR DROP LITERAL
 3007              	 #	;*
 3008              	 #
 3009              	 #	This word searches the dictionary for a word and returns the address
 3010              	 #	of its parameter field.
 3011              	 #
 3012              	 #	It's essentially a more user-friendly front-end to -FIND.
 3013              	
 3014 1775 A127B0FF 		colon "Tick","'","VLIST"
 3014      FFFF99EB 
 3014      FFFF
 3015 177f 5AFDFFFF 		offset MinusFind
 3016 1783 86EEFFFF 		offset ZEq
 3017 1787 AF050000 		offset Zero
 3018 178b 4D010000 		offset QError
 3019 178f 76EDFFFF 		offset DROP
 3020 1793 EBF3FFFF 		offset LITERAL
 3021 1797 B3FBFFFF 		offset SemiS
 3022              	
 3023              	 #	: word		( c -- <get next word to end of dictionary,
 3024              	 #			  delimited with c or null > )
 3025              	 #	  tib @
 3026              	 #	  in @ + swap enclose	( get the word )
 3027              	 #	  here lit 0x22 blanks  ( blank space after the word )
 3028              	 #	  in +! over - >r r here c! + here 1+ r> cmove
 3029              	 #
 3030              	 #	This routine looks at the current data in the terminal input buffer
 3031              	 #	(tib) for a word delimited by the specified character. The string
 3032              	 #	containing that word is appended to the dictionary (starting at
 3033              	 #	here) after a byte giving the length of the word.
 3034              	 #
 3035              	 #	Note that word is sort of trusting in that it expects you to not
 3036              	 #	type a word in longer than 32 characters. The original code also
 3037              	 #	has this problem. Maybe I should fix this... *** note ***
 3038              	 #
 3039              	 #	The main reason for the blanks bit seems to be to guarantee that
 3040              	 #	NUMBER will find a blank when it finishes fiddling with the word.
 3041              	
 3042 179b A4574F52 		colon "WORD","WORD","Tick"	# c
 3042      44D5FFFF 
GAS LISTING nv32forth.s 			page 62


 3042      FF70EBFF 
 3042      FF
 3043 17a8 CA040000 		offset TIB		# Where to look for the word
 3044 17ac 43F2FFFF 		offset Fetch		# c tib
 3045 17b0 E0040000 		offset IN		# Current offset in tib
 3046 17b4 3BF2FFFF 		offset Fetch		# c tib in
 3047 17b8 D8EEFFFF 		offset Plus		# c tib+in
 3048 17bc EAECFFFF 		offset SWAP		# tib+in c
 3049 17c0 49F7FFFF 		offset ENCLOSE		# tib+in first last next
 3050 17c4 18F4FFFF 		offset HERE 
 3051 17c8 7BF3FFFF 		literal 0x22		# tib+in first last next here 0x22
 3051      22000000 
 3052 17d0 5BF3FFFF 		offset BLANKS		# tib+in first last next
 3053 17d4 BC040000 		offset IN		# Bump IN past the word
 3054 17d8 0AEEFFFF 		offset PlusStore	# tib+in first last
 3055 17dc 05EDFFFF 		offset OVER		# tib+in first last first
 3056 17e0 A7EDFFFF 		offset Subtract		# tib+in first wordlength
 3057 17e4 70ECFFFF 		offset ToR
 3058 17e8 8BECFFFF 		offset R		# tib+in first wordlength
 3059 17ec F0F3FFFF 		offset HERE		# tib+in first wordlength here
 3060 17f0 4AF2FFFF 		offset CStore		# Store the length of the word
 3061              					# tib+in first
 3062 17f4 9CEEFFFF 		offset Plus		# tib+bin+first
 3063 17f8 E4F3FFFF 		offset HERE		# tib+in+first here
 3064 17fc C8EEFFFF 		offset OnePlus		# tib+in+first here+1
 3065 1800 64ECFFFF 		offset FromR		# tib+in+first here+1 wordlength
 3066 1804 C2F2FFFF 		offset CMOVE		# shazam!
 3067 1808 42FBFFFF 		offset SemiS
 3068              	
 3069              	 #	: execute		( cfa -- )
 3070              	 #
 3071              	 #	Given the address of a FORTH word, the word is executed. INTERPRET
 3072              	 #	uses this to execute words you type at the console.
 3073              	
 3074 180c A7455845 		code "EXECUTE","EXECUTE","WORD"
 3074      43555445 
 3074      87FFFFFF 
 3074      04000000 
 3075 181c D08759   		movl (r7)+,r9		# Get address of routine to execute
 3076 181f C1695958 		addl3 (r9),r9,r8	# Fetch the offset AND convert to an address
 3077 1823 1768     		jmp (r8)		# Execute the word.
 3078              	
 3079              	 #	: (find)		( target start -- 0 <if not found>
 3080              	 #					       -- pfa lengthbyte  1 <if found> )
 3081              	 #
 3082              	 #	Search the directory for the specified word
 3083              	
 3084 1825 A6284649 		code "PFind","(FIND)","EXECUTE"
 3084      4E4429E0 
 3084      FFFFFF04 
 3084      000000
 3085              	
 3086              	 #	We start off with 4(AP) pointing to the string we're searching
 3087              	 #	for and (AP) pointing to the place we're supposed to start
 3088              	 #	looking.
 3089              	
 3090              	PFind1:
GAS LISTING nv32forth.s 			page 63


 3091              	
 3092              	 #	First we have to compare the length bytes. We need to strip flag
 3093              	 #	bits off the length byte at Start except for the smudge bit.
 3094              	
 3095 1834 8B8FE0B7 		bicb3 $0xe0,*(r7),r0	# Strip the bits
 3095      0050
 3096 183a 9150B704 		cmpb r0,*4(r7)		# Do the length bytes match?
 3097 183e 1235     		bneq PFind2		# If not, it can't be a match
 3098              	
 3099              	 #	We have strings of the same length. Now compare the strings
 3100              	
 3101 1840 D06754   		movl (r7),r4		# Get addresses
 3102 1843 D0A70455 		movl 4(r7),r5
 3103 1847 D654     		incl r4			# Bump past length byte
 3104 1849 D655     		incl r5
 3105 184b 9AB70459 		movzbl *4(r7),r9	# Need a word string length
 3106              	
 3107              	#	cmpc3 r9,(r4),(r5)	# Compare them
 3108 184f 918485   	0:	cmpb (r4)+,(r5)+	# MicroVAX II doesn't do CMPC3
 3109 1852 1221     		bneq PFind2
 3110 1854 F559F8   		sobgtr r9,0b
 3111              	
 3112              	 #	The strings matched. Diddle the stack.
 3113              	
 3114 1857 8B8FE0B7 		bicb3 $0xe0,*(r7),r1	# Figure out where the PFA is
 3114      0051
 3115 185d 9A5151   		movzbl r1,r1
 3116 1860 C1516750 		addl3 r1,(r7),r0	# Here's the LFA
 3117 1864 9AB70051 		movzbl *(r7),r1		# Get raw length byte again
 3118 1868 C10950A7 		addl3 $9,r0,4(r7)	# There's the PFA, and don't forget the
 3118      04
 3119              					# length byte...
 3120 186d 9A5167   		movzbl r1,(r7)		# And the length
 3121 1870 9A0177   		movzbl $1,-(r7)		# And success
 3122 1873 176B     		jmp (r11)
 3123              	
 3124              	 #	The strings didn't match. Look at the next one.
 3125              	
 3126              	PFind2:
 3127              	
 3128 1875 8B8FE0B7 		bicb3 $0xe0,*(r7),r0	# Get length of string
 3128      0050
 3129 187b 9A5050   		movzbl r0,r0
 3130 187e C05067   		addl2 r0,(r7)		# Make address of LFA
 3131 1881 D667     		incl (r7)		# (account for the length byte)
 3132 1883 D0B70050 		movl *(r7),r0		# Get link field value
 3133 1887 D550     		tstl r0			# Is it the end flag?
 3134 1889 1305     		beql PFind3
 3135 188b C05067   		addl2 r0,(r7)		# Update the start address
 3136 188e 11A4     		brb PFind1		# Keep going
 3137              	
 3138              	 #	Went to the end of the dictionary
 3139              	
 3140              	PFind3:
 3141              	
 3142 1890 D587     		tstl (r7)+		# Discard starting address
 3143 1892 D467     		clrl (r7)		# Signal failure
GAS LISTING nv32forth.s 			page 64


 3144 1894 176B     		jmp (r11)
 3145              	
 3146              	 #	: ERROR		( N -- <ISSUE ERROR #N> )
 3147              	 #	  HERE COUNT TYPE (.") "? ERR # " ( THEN )
 3148              	 #	  .
 3149              	 #	  SP!		( EMPTY THE STACK )
 3150              	 #	  QUIT		( THEN )
 3151              	 #	;
 3152              	 #
 3153              	 #	This word is invoked if there's some sort of error. It displays the
 3154              	 #	string at the end of the dictionary to hopefully give some context
 3155              	 #	for the error; INTERPRET works by building words at the end of the
 3156              	 #	dictionary and then searching for them. This should be the name of
 3157              	 #	the last word INTERPRET searched for.
 3158              	 #
 3159              	 #	$$$
 3160              	
 3161 1896 A5455252 		colon "ERROR","ERROR","PFind"
 3161      4F5289FF 
 3161      FFFF74EA 
 3161      FFFF
 3162 18a4 38F3FFFF 		offset HERE		# Display name of last word searched for.
 3163 18a8 5EF5FFFF 		offset COUNT
 3164 18ac 3BF5FFFF 		offset TYPE
 3165 18b0 6CF5FFFF 		offset PDotQuote	# And Huh?
 3166 18b4 083F204D 		string "? MSG # "
 3166      53472023 
 3166      20
 3167 18bd 9DF9FFFF 		offset Dot
 3168 18c1 77ECFFFF 		offset SPStore		# Initialize math stack
 3169 18c5 4F020000 		offset QUIT		# Initialize the rest of the system
 3170 18c9 81FAFFFF 		offset SemiS
 3171              	
 3172              	 #	: ?ERROR	( F N -- <IF F, DO ERROR #N> )
 3173              	 #	  SWAP
 3174              	 #	  0BRANCH QERR1
 3175              	 #	  ERROR		( IF <YOU CAN'T RETURN FROM ERROR> )
 3176              	 #	LABEL QERR1
 3177              	 #	  DROP		( THEN )
 3178              	 #	;
 3179              	 #
 3180              	 #	If F is non-zero, error message #N is displayed.
 3181              	
 3182 18cd A63F4552 		colon "QError","?ERROR","ERROR"
 3182      524F52C2 
 3182      FFFFFF3C 
 3182      EAFFFF
 3183 18dc CAEBFFFF 		offset SWAP	# ( F N -- N F )
 3184 18e0 7FEAFFFF 		offset ZBranch	# If F is zero, go. ( N F -- N )
 3185 18e4 08000000 		offset QErr1
 3186 18e8 B8FFFFFF 		offset ERROR	# Argh! Complain.
 3187 18ec 19ECFFFF 	QErr1:	offset DROP	# ( N -- )
 3188 18f0 5AFAFFFF 		offset SemiS
 3189              	
 3190              	 #	: ?COMP		( GIVE ERR#17 IF NOT COMPILING )
 3191              	 #	  STATE @ 0= LIT 17 ?ERROR
 3192              	 #	;
GAS LISTING nv32forth.s 			page 65


 3193              	 #
 3194              	 #	This word is used by various compiling words to verify that the
 3195              	 #	FORTH system is compiling. If not, it will abort and give error
 3196              	 #	# 17.
 3197              	 #
 3198              	 #	The variable STATE is checked to see if we're compiling. STATE is
 3199              	 #	0 while interpreting and non-0 while compiling.
 3200              	
 3201 18f4 A53F434F 		colon "QComp","?COMP","QError"
 3201      4D50D3FF 
 3201      FFFF16EA 
 3201      FFFF
 3202 1902 B4030000 		offset STATE
 3203 1906 E9F0FFFF 		offset Fetch
 3204 190a FFECFFFF 		offset ZEq		# Complement STATE; return 1 if 0 & vice-versa
 3205 190e 35F2FFFF 		literal 17
 3205      11000000 
 3206 1916 C2FFFFFF 		offset QError
 3207 191a 30FAFFFF 		offset SemiS
 3208              	
 3209              	 #	: ?EXEC		( GIVE ERR #18 IF NOT EXECUTING )
 3210              	 #	  STATE @ LIT 18 ?ERROR
 3211              	 #	;
 3212              	 #
 3213              	 #	If we're not compiling, we must be "executing". I don't know why
 3214              	 #	this isn't ?INTERP, but I'm not complaining.
 3215              	
 3216 191e A53F4558 		colon "QExec","?EXEC","QComp"
 3216      4543D0FF 
 3216      FFFFECE9 
 3216      FFFF
 3217 192c 8A030000 		offset STATE
 3218 1930 BFF0FFFF 		offset Fetch
 3219 1934 0FF2FFFF 		literal 18
 3219      12000000 
 3220 193c 9CFFFFFF 		offset QError
 3221 1940 0AFAFFFF 		offset SemiS
 3222              	
 3223              	 #	: ?PAIRS	( GIVE ERR #19 IF PAIRS DON'T MATCH )
 3224              	 #	  - LIT 19 ?ERROR
 3225              	 #	;
 3226              	 #
 3227              	 #	This word is used by compiling words like THEN, LOOP, etc. to make
 3228              	 #	sure we're ending the correct type of structure.
 3229              	 #
 3230              	 #	While compiling a structure, one of these words will push their
 3231              	 #	information and a code for the type of structure on the stack.
 3232              	 #	This word just makes certain the top two words of the stack are
 3233              	 #	the same.
 3234              	
 3235 1944 A63F5041 		colon "QPairs","?PAIRS","QExec"
 3235      495253D3 
 3235      FFFFFFC5 
 3235      E9FFFF
 3236 1953 34ECFFFF 		offset Subtract
 3237 1957 ECF1FFFF 		literal 19
 3237      13000000 
GAS LISTING nv32forth.s 			page 66


 3238 195f 79FFFFFF 		offset QError
 3239 1963 E7F9FFFF 		offset SemiS
 3240              	
 3241              	 #	: ?CSP		( GIVE ERR#20 IF CSP & SP DON'T MATCH )
 3242              	 #	  SP@ CSP @ - LIT 20 ?ERROR
 3243              	 #	;
 3244              	 #
 3245              	 #	I'm not sure I know what this is about; I think it's used occasionally
 3246              	 #	to verify all of the information put on the stack while compiling has
 3247              	 #	come back off.
 3248              	
 3249 1967 A43F4353 		colon "QCSP","?CSP","QPairs"
 3249      50D8FFFF 
 3249      FFA4E9FF 
 3249      FF
 3250 1974 B3EBFFFF 		offset SPFetch
 3251 1978 6F030000 		offset CSP
 3252 197c 73F0FFFF 		offset Fetch
 3253 1980 07ECFFFF 		offset Subtract
 3254 1984 BFF1FFFF 		literal 20
 3254      14000000 
 3255 198c 4CFFFFFF 		offset QError
 3256 1990 BAF9FFFF 		offset SemiS
 3257              	
 3258              	 #	: ?stack		( error if math stack overflow or underflow )
 3259              	 #
 3260              	 #	I've stubbed this out because if there's a math stack overflow my
 3261              	 #	return stack is gonna be hosed anyway.
 3262              	
 3263 1994 A63F5354 		colon "QStack","?STACK","QCSP"
 3263      41434BCC 
 3263      FFFFFF75 
 3263      E9FFFF
 3264 19a3 A7F9FFFF 		offset SemiS
 3265              	
 3266              	 #	: IF
 3267              	 #	  COMPILE 0BRANCH HERE 0 , 2
 3268              	 #	;*
 3269              	 #
 3270              	 #	This word compiles an IF into the code. If drops a conditional
 3271              	 #	branch followed by space for the offset. The location of the
 3272              	 #	offset is remembered for future use by ELSE and THEN.
 3273              	
 3274 19a7 E24946EA 		colon "IF","IF","QStack",Immediate
 3274      FFFFFF66 
 3274      E9FFFF
 3275 19b2 AAFCFFFF 		offset COMPILE
 3276 19b6 A9E9FFFF 		offset ZBranch
 3277 19ba 22F2FFFF 		offset HERE
 3278 19be 78030000 		offset Zero
 3279 19c2 52F2FFFF 		offset Comma
 3280 19c6 8C030000 		offset Two
 3281 19ca 80F9FFFF 		offset SemiS
 3282              	
 3283              	 #	: ELSE
 3284              	 #	  2 ?PAIRS COMPILE BRANCH HERE 0 , SWAP 2 ENDIF 2
 3285              	 #	;*
GAS LISTING nv32forth.s 			page 67


 3286              	 #
 3287              	 #	This word tosses in the false part of a conditional. It does two
 3288              	 #	things:
 3289              	 #
 3290              	 #	1)	it compiles a branch at the end of the true part of the
 3291              	 #		conditional to point at the end of the whole thing.
 3292              	 #
 3293              	 #	2)	it resolves the branch left open by IF to point to the
 3294              	 #		starting of the false code.
 3295              	
 3296 19ce E4454C53 		colon "ELSE","ELSE","IF",Immediate
 3296      45D4FFFF 
 3296      FF3DE9FF 
 3296      FF
 3297 19db 77030000 		offset Two
 3298 19df 70FFFFFF 		offset QPairs
 3299 19e3 79FCFFFF 		offset COMPILE
 3300 19e7 63E9FFFF 		offset BRANCH
 3301 19eb F1F1FFFF 		offset HERE
 3302 19ef 47030000 		offset Zero
 3303 19f3 21F2FFFF 		offset Comma
 3304 19f7 AFEAFFFF 		offset SWAP
 3305 19fb 57030000 		offset Two
 3306 19ff 15000000 		offset THEN
 3307 1a03 4F030000 		offset Two
 3308 1a07 43F9FFFF 		offset SemiS
 3309              	
 3310              	 #	: THEN
 3311              	 #	  ?COMP 2 ?PAIRS HERE OVER - SWAP !
 3312              	 #	;*
 3313              	 #
 3314              	 #	This word ends a conditional. It resolves the branch left by either
 3315              	 #	IF or ELSE to point HERE.
 3316              	 #
 3317              	 #	$$$
 3318              	
 3319 1a0b E4544845 		colon "THEN","THEN","ELSE",Immediate
 3319      4EBEFFFF 
 3319      FF00E9FF 
 3319      FF
 3320 1a18 E6FEFFFF 		offset QComp
 3321 1a1c 36030000 		offset Two
 3322 1a20 2FFFFFFF 		offset QPairs
 3323 1a24 B8F1FFFF 		offset HERE
 3324 1a28 B9EAFFFF 		offset OVER
 3325 1a2c 5BEBFFFF 		offset Subtract
 3326 1a30 76EAFFFF 		offset SWAP
 3327 1a34 F3EFFFFF 		offset Store
 3328 1a38 12F9FFFF 		offset SemiS
 3329              	
 3330              	 #	: BEGIN
 3331              	 #	  ?COMP HERE 1
 3332              	 #	;*
 3333              	 #
 3334              	 #	This word starts a BEGIN loop. It remembers where the top of the
 3335              	 #	loop is for use by UNTIL, WHILE, REPEAT, and AGAIN.
 3336              	
GAS LISTING nv32forth.s 			page 68


 3337 1a3c E5424547 		colon "BEGIN","BEGIN","THEN",Immediate
 3337      494EC9FF 
 3337      FFFFCEE8 
 3337      FFFF
 3338 1a4a B4FEFFFF 		offset QComp
 3339 1a4e 8EF1FFFF 		offset HERE
 3340 1a52 F2020000 		offset One
 3341 1a56 F4F8FFFF 		offset SemiS
 3342              	
 3343              	 #	: UNTIL
 3344              	 #	  1 ?PAIRS COMPILE 0BRANCH O,
 3345              	 #	;*
 3346              	 #
 3347              	 #	Here's the end of a BEGIN...UNTIL thingie. It compiles a branch that
 3348              	 #	will go back to the top of the loop if the item on top of the math
 3349              	 #	stack is 0.
 3350              	 #
 3351              	 #	$$$
 3352              	
 3353 1a5a E5554E54 		colon "UNTIL","UNTIL","BEGIN",Immediate
 3353      494CDCFF 
 3353      FFFFB0E8 
 3353      FFFF
 3354 1a68 DC020000 		offset One
 3355 1a6c E3FEFFFF 		offset QPairs
 3356 1a70 ECFBFFFF 		offset COMPILE
 3357 1a74 EBE8FFFF 		offset ZBranch
 3358 1a78 FDF1FFFF 		offset OComma
 3359 1a7c CEF8FFFF 		offset SemiS
 3360              	
 3361              	 #	: AGAIN
 3362              	 #	  ?COMP
 3363              	 #	  1 ?PAIRS COMPILE BRANCH O,
 3364              	 #	;*
 3365              	 #
 3366              	 #	COMPILEs an unconditional branch to the beginning of the loop.
 3367              	 #
 3368              	 #	$$$
 3369              	
 3370 1a80 E5414741 		colon "AGAIN","AGAIN","UNTIL",Immediate
 3370      494ED4FF 
 3370      FFFF8AE8 
 3370      FFFF
 3371 1a8e 70FEFFFF 		offset QComp
 3372 1a92 B2020000 		offset One
 3373 1a96 B9FEFFFF 		offset QPairs
 3374 1a9a C2FBFFFF 		offset COMPILE
 3375 1a9e ACE8FFFF 		offset BRANCH
 3376 1aa2 D3F1FFFF 		offset OComma
 3377 1aa6 A4F8FFFF 		offset SemiS
 3378              	
 3379              	 #	: REPEAT
 3380              	 #	  ?COMP
 3381              	 #	  >R >R AGAIN R> R> 2 -
 3382              	 #	  ENDIF
 3383              	 #	;*
 3384              	 #
GAS LISTING nv32forth.s 			page 69


 3385              	 #	COMPILEs an unconditional branch back to the top of the loop and
 3386              	 #	then fills in the booger left behind by WHILE.
 3387              	
 3388 1aaa E6524550 		colon "REPEAT","REPEAT","AGAIN",Immediate
 3388      454154CF 
 3388      FFFFFF5F 
 3388      E8FFFF
 3389 1ab9 45FEFFFF 		offset QComp
 3390 1abd 97E9FFFF 		offset ToR
 3391 1ac1 93E9FFFF 		offset ToR
 3392 1ac5 C5FFFFFF 		offset AGAIN
 3393 1ac9 9BE9FFFF 		offset FromR
 3394 1acd 97E9FFFF 		offset FromR
 3395 1ad1 81020000 		offset Two
 3396 1ad5 B2EAFFFF 		offset Subtract
 3397 1ad9 3BFFFFFF 		offset THEN
 3398 1add 6DF8FFFF 		offset SemiS
 3399              	
 3400              	 #	: WHILE
 3401              	 #	  IF 2+
 3402              	 #	;*
 3403              	 #
 3404              	 #	COMPILEs an exit to the loop if the top of stack is zero. REPEAT
 3405              	 #	fills in the booger left behind by IF.
 3406              	
 3407 1ae1 E5574849 		colon "WHILE","WHILE","REPEAT",Immediate
 3407      4C45C3FF 
 3407      FFFF29E8 
 3407      FFFF
 3408 1aef BFFEFFFF 		offset IF
 3409 1af3 E8EBFFFF 		offset TwoPlus
 3410 1af7 53F8FFFF 		offset SemiS
 3411              	
 3412              	 #	: NOP ; ( DO-NOTHING )
 3413              	 #
 3414              	 #	A classic that should exist in any language...
 3415              	
 3416 1afb A34E4F50 		colon "NOP","NOP","WHILE"
 3416      E2FFFFFF 
 3416      11E8FFFF 
 3417 1b07 43F8FFFF 		offset SemiS
 3418              	
 3419              	 #	: QUIT
 3420              	 #	  [
 3421              	 #	LABEL Q1
 3422              	 #	  RP! CR QUERY INTERPRET	( BEGIN )
 3423              	 #	  STATE @ 0=
 3424              	 #	  0BRANCH Q2
 3425              	 #	  (.") "OK"			( IF )
 3426              	 #	LABEL Q2
 3427              	 #	  BRANCH Q1			( ENDIF AGAIN )
 3428              	 #	;
 3429              	 #
 3430              	 #	This word is the main loop for the FORTH system. It initializes
 3431              	 #	the return stack, gets a command line, and interprets it. After
 3432              	 #	the command line is done, OK is printed if we're not compiling.
 3433              	
GAS LISTING nv32forth.s 			page 70


 3434 1b0b A4515549 		colon "QUIT","QUIT","NOP"
 3434      54EBFFFF 
 3434      FF00E8FF 
 3434      FF
 3435 1b18 41F8FFFF 		offset LBracket
 3436 1b1c 76E9FFFF 	Q1:	offset RPStore
 3437 1b20 F4F1FFFF 		offset CR
 3438 1b24 85F3FFFF 		offset QUERY
 3439 1b28 8F000000 		offset INTERPRET
 3440 1b2c 8A010000 		offset STATE
 3441 1b30 BFEEFFFF 		offset Fetch
 3442 1b34 D5EAFFFF 		offset ZEq
 3443 1b38 27E8FFFF 		offset ZBranch
 3444 1b3c 0B000000 		offset Q2
 3445 1b40 DCF2FFFF 		offset PDotQuote
 3446 1b44 024F4B   		string "OK"
 3447 1b47 03E8FFFF 	Q2:	offset BRANCH
 3448 1b4b D1FFFFFF 		offset Q1
 3449 1b4f FBF7FFFF 		offset SemiS
 3450              	
 3451              	 #	: ABORT
 3452              	 #	  .on
 3453              	 #	  SP! DECIMAL ?STACK CR
 3454              	 #	  .CPU				( PRINT THE GREETING )
 3455              	 #	  ( FORTH )
 3456              	 #	  QUIT
 3457              	 #	;
 3458              	 #
 3459              	 #	This word starts the ball rolling; the low-level machine code causes
 3460              	 #	this word to be executed at startup. It initializes the math stack,
 3461              	 #	prints a banner, and does QUIT to get and execute a command line.
 3462              	 #
 3463              	 #	$$$
 3464              	
 3465 1b53 A541424F 		colon "ABORT","ABORT","QUIT"
 3465      5254B2FF 
 3465      FFFFB7E7 
 3465      FFFF
 3466 1b61 8CF1FFFF 		offset DotOn
 3467 1b65 D3E9FFFF 		offset SPStore
 3468 1b69 11F2FFFF 		offset DECIMAL
 3469 1b6d 32FEFFFF 		offset QStack
 3470 1b71 A3F1FFFF 		offset CR
 3471 1b75 15000000 		offset DotCPU
 3472 1b79 9BFFFFFF 		offset QUIT
 3473 1b7d CDF7FFFF 		offset SemiS
 3474              	
 3475              	 #	: .CPU
 3476              	 #	  (.") "NV5 PCACHE FORTH"
 3477              	 #	;
 3478              	 #
 3479              	 #	This word displays a banner identifying the FORTH system.
 3480              	
 3481 1b81 A42E4350 		colon "DotCPU",".CPU","ABORT"
 3481      55CDFFFF 
 3481      FF8AE7FF 
 3481      FF
GAS LISTING nv32forth.s 			page 71


 3482 1b8e 8EF2FFFF 		offset PDotQuote
 3483 1b92 0E43502F 		string "CP/M-VAX FORTH"
 3483      4D2D5641 
 3483      5820464F 
 3483      525448
 3484 1ba1 73F1FFFF 		offset CR
 3485 1ba5 A5F7FFFF 		offset SemiS
 3486              	
 3487              	 #	: INTERPRET
 3488              	 #	LABEL I1
 3489              	 #	  -FIND			( BEGIN )
 3490              	 #	  0BRANCH I2
 3491              	 #	  STATE @ <		( IF )
 3492              	 #	  OBRANCH I3
 3493              	 #	  CFA o,
 3494              	 #	  BRANCH I4
 3495              	 #	LABEL I3
 3496              	 #	  CFA EXECUTE		( ELSE )
 3497              	 #	LABEL I4
 3498              	 #	  ?STACK		( ENDIF )
 3499              	 #	  BRANCH I5
 3500              	 #	LABEL I2
 3501              	 #	  HERE NUMBER DPL @ 1+
 3502              	 #	  0BRANCH I6
 3503              	 #	  DLITERAL		( IF )
 3504              	 #	  BRANCH I7
 3505              	 #	LABEL I6
 3506              	 #	  DROP LITERAL		( ELSE )
 3507              	 #	LABEL I7
 3508              	 #	  ?STACK		( ENDIF ENDIF )
 3509              	 #	LABEL I5
 3510              	 #	  BRANCH I1		( AGAIN )
 3511              	 #	;
 3512              	 #
 3513              	 #	Here's the FORTH interpreter. Given a line in TIB, it whacks off
 3514              	 #	a word from the line and looks it up in the dictionary. If it
 3515              	 #	can't find the word, it assumes it's a number.
 3516              	 #
 3517              	 #	Having located a word, what it does with the word depends on the
 3518              	 #	state it's in:
 3519              	 #
 3520              	 #	- If interpreting, the word is executed.
 3521              	 #	- If compiling, the word is executed if it's an IMMEDIATE word.
 3522              	 #	- If compiling, a reference to the word is added to the end of the
 3523              	 #	  dictionary if it's not an IMMEDIATE word.
 3524              	 #
 3525              	 #	Having parsed a number, what it does with the number depends on the
 3526              	 #	state it's in:
 3527              	 #
 3528              	 #	- If interpreting, the number is pushed on the stack.
 3529              	 #	- If compiling, the number is added as a literal to the end of
 3530              	 #	  the dictionary.
 3531              	 #
 3532              	 #	(all this work is actually done by LITERAL or DLITERAL...)
 3533              	 #
 3534              	 #	Strangely enough, INTERPRET seems to believe a number is a double-
 3535              	 #	precision number if it contains a decimal point. I don't understand
GAS LISTING nv32forth.s 			page 72


 3536              	 #	_that_ one...
 3537              	 #
 3538              	 #	You have probably noticed that INTERPRET has no exit. What happens 
 3539              	 #	at the end of a line? Well, I'll tell you, but I'm not happy about
 3540              	 #	it; this is one of my biggest gripes about FORTH: the whole damn
 3541              	 #	system is held together by side-effects.
 3542              	 #
 3543              	 #	INTERPRET expects to be fed a line that was read in using EXPECT.
 3544              	 #	EXPECT tosses a null at the end of a line (assuming there's room for
 3545              	 #	it, of course). ENCLOSE knows that a null ends the line, so it won't
 3546              	 #	search past a null. WORD therefore sees a one-byte word at the end
 3547              	 #	of every line containing null. INTERPRET dutifully searches for the
 3548              	 #	null word. The null word is immediate, so it will be executed even
 3549              	 #	if we're compiling.
 3550              	 #
 3551              	 #	The null word DROPS AN ITEM FROM THE RETURN STACK and then returns.
 3552              	 #	So, when the null word returns, it doesn't return to INTERPRET. Oh,
 3553              	 #	no, that would be too good for null. It returns to the word that
 3554              	 #	called INTERPRET.
 3555              	 #
 3556              	 #	OK, suppose I type something that's not in the dictionary. What
 3557              	 #	happens? Well, NUMBER sees that (NUMBER) gave up on something that's
 3558              	 #	not a space or a decimal point, so it ERRORs out. ERROR calls QUIT,
 3559              	 #	which initializes the return stack and does a new QUERY/INTERPRET.
 3560              	 #	In short, INTERPRET gets aborted.
 3561              	 #
 3562              	 #	What a mess!!!
 3563              	
 3564 1ba9 A9494E54 		colon "INTERPRET","INTERPRET","DotCPU"
 3564      45525052 
 3564      4554CEFF 
 3564      FFFF5DE7 
 3564      FFFF
 3565 1bbb 1EF9FFFF 	I1:	offset MinusFind	# ( pfa length 1 ) or ( 0 )
 3566 1bbf A0E7FFFF 		offset ZBranch		# If not found, go
 3567 1bc3 3C000000 		offset I2
 3568 1bc7 EF000000 		offset STATE
 3569 1bcb 24EEFFFF 		offset Fetch		# ( pfa state )
 3570 1bcf C7E9FFFF 		offset Less
 3571 1bd3 8CE7FFFF 		offset ZBranch		# Go if not ( pfa )
 3572 1bd7 14000000 		offset I3
 3573 1bdb 58F9FFFF 		offset CFA		# ( cfa )
 3574 1bdf 96F0FFFF 		offset OComma		# COMPILE CFA into word
 3575 1be3 67E7FFFF 		offset BRANCH
 3576 1be7 0C000000 		offset I4
 3577 1beb 48F9FFFF 	I3:	offset CFA		# ( pfa -- cfa )
 3578 1bef 29FCFFFF 		offset EXECUTE		# do it
 3579 1bf3 ACFDFFFF 	I4:	offset QStack		# Check for overflow
 3580 1bf7 53E7FFFF 		offset BRANCH
 3581 1bfb 38000000 		offset I5
 3582 1bff DDEFFFFF 	I2:	offset HERE		# Couldn't find the word; is it a number?
 3583 1c03 0CF4FFFF 		offset NUMBER		# ( low high )
 3584 1c07 D0000000 		offset DPL		# Is it double precision?
 3585 1c0b E4EDFFFF 		offset Fetch		# ( low high dpl )
 3586 1c0f B5EAFFFF 		offset OnePlus
 3587 1c13 4CE7FFFF 		offset ZBranch		# Go if it's single precision
 3588 1c17 10000000 		offset I6
GAS LISTING nv32forth.s 			page 73


 3589 1c1b 94EFFFFF 		offset DLITERAL		# It's double precision
 3590 1c1f 2BE7FFFF 		offset BRANCH
 3591 1c23 0C000000 		offset I7
 3592 1c27 DEE8FFFF 	I6:	offset DROP		# ( low )
 3593 1c2b 53EFFFFF 		offset LITERAL
 3594 1c2f 70FDFFFF 	I7:	offset QStack
 3595 1c33 17E7FFFF 	I5:	offset BRANCH
 3596 1c37 84FFFFFF 		offset I1
 3597 1c3b 0FF7FFFF 		offset SemiS		# Like we'll ever get here...
 3598              	
 3599              	 #	: exit		( exits current word )
 3600              	 #	  R> DROP ;
 3601              	 #
 3602              	 #	This is an ACE word to exit the current word. It can't be used in
 3603              	 #	a DO loop, as it just drops its return address from the stack causing
 3604              	 #	a return to the caller's caller.
 3605              	
 3606 1c3f A4455849 		colon "EXIT","EXIT","INTERPRET"
 3606      5465FFFF 
 3606      FFCCE6FF 
 3606      FF
 3607 1c4c 18E8FFFF 		offset FromR
 3608 1c50 B5E8FFFF 		offset DROP
 3609 1c54 F6F6FFFF 		offset SemiS
 3610              	
 3611              	 #;	Breakpoint opportunity: a machine code word that gives
 3612              	 #;	VAX DEBUG have a symbol it can break at
 3613              	 #
 3614              	 #	Code BPT
 3615              	 #BreakHere::
 3616              	 #	JMP (R11)
 3617              	
 3618              	 #	User Variables. These are intended to be addressed by an offset
 3619              	 #	to the "user pointer" to facilitate multitasking. I'm just making
 3620              	 #	them normal variables.
 3621              	
 3622 1c58 A5285449 		variable "PTib","(TIB)","EXIT"
 3622      4229E1FF 
 3622      FFFFC1E6 
 3622      FFFF0000 
 3622      0000
 3623 1c6a A3544942 		variable "TIB","TIB","PTib"	# Terminal input goes here
 3623      EAFFFFFF 
 3623      B1E6FFFF 
 3623      00000000 
 3624 1c7a A24450ED 		variable "DP","DP","TIB"	# End of directory
 3624      FFFFFFA2 
 3624      E6FFFF00 
 3624      000000
 3625 1c89 A2494EEE 		variable "IN","IN","DP"		# Current offset INto TIB
 3625      FFFFFF93 
 3625      E6FFFF00 
 3625      000000
 3626 1c98 A7435552 		variable "CURRENT","CURRENT","IN" # NFA of word we're workin' on
 3626      52454E54 
 3626      E9FFFFFF 
 3626      7FE6FFFF 
GAS LISTING nv32forth.s 			page 74


 3626      00000000 
 3627 1cac A5535441 		variable "STATE","STATE","CURRENT" # 0 = interpreting?
 3627      5445E6FF 
 3627      FFFF6DE6 
 3627      FFFF0000 
 3627      0000
 3628 1cbe A4424153 		variable "BASE","BASE","STATE"	# Current number base
 3628      45E9FFFF 
 3628      FF5CE6FF 
 3628      FF000000 
 3628      00
 3629 1ccf A344504C 		variable "DPL","DPL","BASE" # 1 = NUMBER decided it's double-precision
 3629      EBFFFFFF 
 3629      4CE6FFFF 
 3629      00000000 
 3630 1cdf A3435350 		variable "CSP","CSP","DPL"	# Used as a temp to wind back stack?
 3630      ECFFFFFF 
 3630      3CE6FFFF 
 3630      00000000 
 3631 1cef A3484C44 		variable "HLD","HLD","CSP"	# Buffer for formatted output
 3631      ECFFFFFF 
 3631      2CE6FFFF 
 3631      00000000 
 3632 1cff A5422F42 		variable "BSlashBuf","B/BUF","HLD" # Size of TIB
 3632      5546EAFF 
 3632      FFFF1AE6 
 3632      FFFF0000 
 3632      0000
 3633              	
 3634 1d11 A2424CEB 		constant "BL","BL","BSlashBuf",32 # Space
 3634      FFFFFF05 
 3634      E6FFFF20 
 3634      000000
 3635              	
 3636 1d20 A3504144 		constant "PAD","PAD","BL",0	# This isn't really a contant; it's 
 3636      EDFFFFFF 
 3636      F5E5FFFF 
 3636      00000000 
 3637              						# initialized by COLD and never written
 3638              						# by FORTH code.
 3639              	
 3640              	 #	These constants are used frequently enough in the code that it
 3641              	 #	makes sense (i.e., saves bytes) to make them words, even with the
 3642              	 #	ZBLIT hack.
 3643              	
 3644 1d30 A130EEFF 		constant "Zero","0","PAD",0
 3644      FFFFE7E5 
 3644      FFFF0000 
 3644      0000
 3645 1d3e A131F0FF 		constant "One","1","Zero",1
 3645      FFFFD9E5 
 3645      FFFF0100 
 3645      0000
 3646 1d4c A132F0FF 		constant "Two","2","One",2
 3646      FFFFCBE5 
 3646      FFFF0200 
 3646      0000
GAS LISTING nv32forth.s 			page 75


 3647              	
 3648 1d5a A448414C 		code "HALT","HALT","Two"
 3648      54EDFFFF 
 3648      FF040000 
 3648      00
 3649 1d67 00       		halt
 3650 1d68 176B     		jmp (r11)
 3651              	
 3652              	#	BASEPAGE	-- address of base page
 3653              	#
 3654              	#	Pushes the address of the base page on the stack.
 3655              	
 3656 1d6a A8424153 		colon "BASEPAGE","BASEPAGE","HALT"
 3656      45504147 
 3656      45E7FFFF 
 3656      FF9DE5FF 
 3656      FF
 3657 1d7b EDEDFFFF 		offset OLIT
 3658 1d7f 9BE2FFFF 		offset __base_page
 3659 1d83 C7F5FFFF 		offset SemiS
 3660              	
 3661              	#	BDOS		parameter, function -- result
 3662              	#
 3663              	#	Calls the BDOS, pushing the return value.
 3664              	
 3665 1d87 A442444F 		code "BDOS","BDOS","BASEPAGE"
 3665      53DEFFFF 
 3665      FF040000 
 3665      00
 3666 1d94 D0A7047E 		movl 4(r7),-(sp)	# Push parameter
 3667 1d98 D0877E   		movl (r7)+,-(sp)	# Push func and pop it
 3668 1d9b D0CF77E2 		movl __bdos_pointer,r0	# call BDOS
 3668      50
 3669 1da0 FB0260   		calls $2,(r0)
 3670 1da3 D05067   		movl r0,(r7)		# Replace parameter with return value
 3671 1da6 176B     		jmp (r11)
 3672              	
 3673              	
 3674              	Forth$$LastWord_NFA:
 3675              	
 3676 1da8 A4434F4C 		code "COLD","COLD","BDOS"
 3676      44DAFFFF 
 3676      FF040000 
 3676      00
 3677              	
 3678              	 #	When we are started, the BIOS/Loader/whatever enters here
 3679              	
 3680              	Forth$$Begin:
 3681 1db5 DECF4FE5 		moval Next,r11
 3681      5B
 3682 1dba DECFAAE4 		moval TibBuffer,PTib_pfa
 3682      CFA5FE
 3683 1dc1 DECFA5E4 		moval TibSpace,TIB_pfa
 3683      CFAEFE
 3684 1dc8 DECFEDE4 		moval TibSpaceEnd,r0
 3684      50
 3685 1dcd DECF99E4 		moval TibSpace,r1
GAS LISTING nv32forth.s 			page 76


 3685      51
 3686 1dd2 C35051CF 		subl3 r0,r1,BSlashBuf_pfa
 3686      35FF
 3687              	 #	movl $(TibSpaceEnd - TibSpace),BSlashBuf_pfa
 3688 1dd8 DEAF2DCF 		moval DictEnd,DP_pfa
 3688      A7FE
 3689 1dde D4CFB2FE 		clrl IN_pfa
 3690 1de2 DEAFC3CF 		moval Forth$$LastWord_NFA,CURRENT_pfa
 3690      C0FE
 3691 1de8 D4CFCEFE 		clrl STATE_pfa
 3692 1dec D00ACFDA 		movl $10,BASE_pfa
 3692      FE
 3693 1df1 D4CFE6FE 		clrl DPL_pfa
 3694 1df5 DECF0FE5 		moval PadSpaceEnd,PAD_pfa
 3694      CF30FF
 3695 1dfc DECF68E4 		moval MathSpace,r7	# initialize math stack pointer
 3695      57
 3696              		
 3697 1e01 DECF5CFD 		moval ABORT+4,r10
 3697      5A
 3698 1e06 176B     		jmp (r11)
 3699              	
 3700              	DictEnd:
 3701              		.end
GAS LISTING nv32forth.s 			page 77


DEFINED SYMBOLS
         nv32forth.s:13     text:00000000 __start
         nv32forth.s:23     text:0000001a __base_page
         nv32forth.s:21     text:00000016 __bdos_pointer
         nv32forth.s:25     text:0000001e __initial_sp
         nv32forth.s:3680   text:00001db5 Forth$$Begin
         nv32forth.s:36     text:00000022 __ConIn_Args
         nv32forth.s:41     text:0000002e ConIn
         nv32forth.s:53     text:00000037 __ConSt_Args
         nv32forth.s:58     text:00000043 ConSt
         nv32forth.s:70     text:0000004c __ConOut_Args
         nv32forth.s:73     text:00000054 __ConOut_Char
         nv32forth.s:76     text:00000058 ConOut
                         absolute:00000040 Immediate
         nv32forth.s:282    text:00000268 MathSpace
         nv32forth.s:287    text:00000268 TibBuffer
         nv32forth.s:290    text:0000026a TibSpace
         nv32forth.s:292    text:000002b9 TibSpaceEnd
         nv32forth.s:299    text:00000308 PadSpaceEnd
         nv32forth.s:321    text:00000308 Next
         nv32forth.s:350    text:00000314 DoCol
         nv32forth.s:357    text:0000031d DoCon
         nv32forth.s:363    text:00000323 DoVar
         nv32forth.s:377    text:00000329 header_temp
         nv32forth.s:377    text:00000329 null_nfa
         nv32forth.s:377    text:0000032b null_lfa
         nv32forth.s:377    text:0000032f null
         nv32forth.s:583    text:00000464 FromR
         nv32forth.s:673    text:00000505 DROP
         nv32forth.s:2486   text:0000134a SemiS
         nv32forth.s:391    text:0000033f BRANCH_nfa
         nv32forth.s:391    text:00000346 BRANCH_lfa
         nv32forth.s:391    text:0000034a BRANCH
                             text:0000034e BRANCH_pfa
         nv32forth.s:392    text:0000034e ZBranch_Branch
         nv32forth.s:406    text:00000353 ZBranch_nfa
         nv32forth.s:406    text:0000035b ZBranch_lfa
         nv32forth.s:406    text:0000035f ZBranch
                             text:00000363 ZBranch_pfa
         nv32forth.s:409    text:00000367 ZBranch_Skip
         nv32forth.s:441    text:0000036b PLoop_nfa
         nv32forth.s:441    text:00000372 PLoop_lfa
         nv32forth.s:441    text:00000376 PLoop
                             text:0000037a PLoop_pfa
         nv32forth.s:443    text:0000037c PLoop_1
         nv32forth.s:466    text:00000388 PPLoop_nfa
         nv32forth.s:466    text:00000390 PPLoop_lfa
         nv32forth.s:466    text:00000394 PPLoop
                             text:00000398 PPLoop_pfa
         nv32forth.s:479    text:0000039d PDo_nfa
         nv32forth.s:479    text:000003a2 PDo_lfa
         nv32forth.s:479    text:000003a6 PDo
                             text:000003aa PDo_pfa
         nv32forth.s:496    text:000003b5 DO_nfa
         nv32forth.s:496    text:000003b8 DO_lfa
         nv32forth.s:496    text:000003bc DO
                             text:000003c0 DO_pfa
GAS LISTING nv32forth.s 			page 78


         nv32forth.s:2891   text:0000165c COMPILE
         nv32forth.s:1555   text:00000bdc HERE
         nv32forth.s:3235   text:0000194f QPairs
         nv32forth.s:1626   text:00000c75 OComma
         nv32forth.s:533    text:00000401 PlusLoop_nfa
         nv32forth.s:533    text:00000407 PlusLoop_lfa
         nv32forth.s:533    text:0000040b PlusLoop
                             text:0000040f PlusLoop_pfa
         nv32forth.s:565    text:0000043e I_nfa
         nv32forth.s:565    text:00000440 I_lfa
         nv32forth.s:565    text:00000444 I
                             text:00000448 I_pfa
         nv32forth.s:566    text:00000448 RI1
         nv32forth.s:574    text:0000044d ToR_nfa
         nv32forth.s:574    text:00000450 ToR_lfa
         nv32forth.s:574    text:00000454 ToR
                             text:00000458 ToR_pfa
         nv32forth.s:583    text:0000045d FromR_nfa
         nv32forth.s:583    text:00000460 FromR_lfa
                             text:00000468 FromR_pfa
         nv32forth.s:597    text:0000046d R_nfa
         nv32forth.s:597    text:0000046f R_lfa
         nv32forth.s:597    text:00000473 R
                             text:00000477 R_pfa
         nv32forth.s:606    text:00000479 RPFetch_nfa
         nv32forth.s:606    text:0000047d RPFetch_lfa
         nv32forth.s:606    text:00000481 RPFetch
                             text:00000485 RPFetch_pfa
         nv32forth.s:623    text:0000048a RPStore_nfa
         nv32forth.s:623    text:0000048e RPStore_lfa
         nv32forth.s:623    text:00000492 RPStore
                             text:00000496 RPStore_pfa
         nv32forth.s:631    text:0000049d SWAP_nfa
         nv32forth.s:631    text:000004a2 SWAP_lfa
         nv32forth.s:631    text:000004a6 SWAP
                             text:000004aa SWAP_pfa
         nv32forth.s:645    text:000004b8 ROT_nfa
         nv32forth.s:645    text:000004bc ROT_lfa
         nv32forth.s:645    text:000004c0 ROT
                             text:000004c4 ROT_pfa
         nv32forth.s:657    text:000004d8 OVER_nfa
         nv32forth.s:657    text:000004dd OVER_lfa
         nv32forth.s:657    text:000004e1 OVER
                             text:000004e5 OVER_pfa
         nv32forth.s:665    text:000004eb DUP_nfa
         nv32forth.s:665    text:000004ef DUP_lfa
         nv32forth.s:665    text:000004f3 DUP
                             text:000004f7 DUP_pfa
         nv32forth.s:673    text:000004fc DROP_nfa
         nv32forth.s:673    text:00000501 DROP_lfa
                             text:00000509 DROP_pfa
         nv32forth.s:682    text:0000050d TwoDUP_nfa
         nv32forth.s:682    text:00000512 TwoDUP_lfa
         nv32forth.s:682    text:00000516 TwoDUP
                             text:0000051a TwoDUP_pfa
         nv32forth.s:693    text:0000051f SPFetch_nfa
         nv32forth.s:693    text:00000523 SPFetch_lfa
GAS LISTING nv32forth.s 			page 79


         nv32forth.s:693    text:00000527 SPFetch
                             text:0000052b SPFetch_pfa
         nv32forth.s:703    text:00000530 SPStore_nfa
         nv32forth.s:703    text:00000534 SPStore_lfa
         nv32forth.s:703    text:00000538 SPStore
                             text:0000053c SPStore_pfa
         nv32forth.s:717    text:00000543 MinusDup_nfa
         nv32forth.s:717    text:00000548 MinusDup_lfa
         nv32forth.s:717    text:0000054c MinusDup
                             text:00000550 MinusDup_pfa
         nv32forth.s:722    text:00000560 DDup1
         nv32forth.s:732    text:00000564 StoreCSP_nfa
         nv32forth.s:732    text:00000569 StoreCSP_lfa
         nv32forth.s:732    text:0000056d StoreCSP
                             text:00000571 StoreCSP_pfa
         nv32forth.s:3630   text:00001ce7 CSP
         nv32forth.s:1341   text:00000a27 Store
         nv32forth.s:743    text:00000581 Subtract_nfa
         nv32forth.s:743    text:00000583 Subtract_lfa
         nv32forth.s:743    text:00000587 Subtract
                             text:0000058b Subtract_pfa
         nv32forth.s:848    text:00000621 ZLess
         nv32forth.s:781    text:000005a6 AND_nfa
         nv32forth.s:781    text:000005aa AND_lfa
         nv32forth.s:781    text:000005ae AND
                             text:000005b2 AND_pfa
         nv32forth.s:791    text:000005ba OR_nfa
         nv32forth.s:791    text:000005bd OR_lfa
         nv32forth.s:791    text:000005c1 OR
                             text:000005c5 OR_pfa
         nv32forth.s:800    text:000005ca XOR_nfa
         nv32forth.s:800    text:000005ce XOR_lfa
         nv32forth.s:800    text:000005d2 XOR
                             text:000005d6 XOR_pfa
         nv32forth.s:809    text:000005db PlusStore_nfa
         nv32forth.s:809    text:000005de PlusStore_lfa
         nv32forth.s:809    text:000005e2 PlusStore
                             text:000005e6 PlusStore_pfa
         nv32forth.s:821    text:000005ee TOGGLE_nfa
         nv32forth.s:821    text:000005f5 TOGGLE_lfa
         nv32forth.s:821    text:000005f9 TOGGLE
                             text:000005fd TOGGLE_pfa
         nv32forth.s:834    text:00000602 ZEq_nfa
         nv32forth.s:834    text:00000605 ZEq_lfa
         nv32forth.s:834    text:00000609 ZEq
                             text:0000060d ZEq_pfa
         nv32forth.s:841    text:00000615 Yes
         nv32forth.s:838    text:00000611 No
         nv32forth.s:848    text:0000061a ZLess_nfa
         nv32forth.s:848    text:0000061d ZLess_lfa
                             text:00000625 ZLess_pfa
         nv32forth.s:859    text:0000062b Equal_nfa
         nv32forth.s:859    text:0000062d Equal_lfa
         nv32forth.s:859    text:00000631 Equal
                             text:00000635 Equal_pfa
         nv32forth.s:870    text:0000063c NotEq_nfa
         nv32forth.s:870    text:0000063f NotEq_lfa
GAS LISTING nv32forth.s 			page 80


         nv32forth.s:870    text:00000643 NotEq
                             text:00000647 NotEq_pfa
         nv32forth.s:881    text:0000064e ULess_nfa
         nv32forth.s:881    text:00000651 ULess_lfa
         nv32forth.s:881    text:00000655 ULess
                             text:00000659 ULess_pfa
         nv32forth.s:889    text:00000661 Greater_nfa
         nv32forth.s:889    text:00000663 Greater_lfa
         nv32forth.s:889    text:00000667 Greater
                             text:0000066b Greater_pfa
         nv32forth.s:901    text:00000677 NotEqual_nfa
         nv32forth.s:901    text:0000067a NotEqual_lfa
         nv32forth.s:901    text:0000067e NotEqual
                             text:00000682 NotEqual_pfa
         nv32forth.s:909    text:0000068a Plus_nfa
         nv32forth.s:909    text:0000068c Plus_lfa
         nv32forth.s:909    text:00000690 Plus
                             text:00000694 Plus_pfa
         nv32forth.s:917    text:00000699 MINUS_nfa
         nv32forth.s:917    text:0000069f MINUS_lfa
         nv32forth.s:917    text:000006a3 MINUS
                             text:000006a7 MINUS_pfa
         nv32forth.s:927    text:000006ac NOT_nfa
         nv32forth.s:927    text:000006b0 NOT_lfa
         nv32forth.s:927    text:000006b4 NOT
                             text:000006b8 NOT_pfa
         nv32forth.s:935    text:000006bd OnePlus_nfa
         nv32forth.s:935    text:000006c0 OnePlus_lfa
         nv32forth.s:935    text:000006c4 OnePlus
                             text:000006c8 OnePlus_pfa
         nv32forth.s:3645   text:00001d44 One
         nv32forth.s:946    text:000006d4 TwoPlus_nfa
         nv32forth.s:946    text:000006d7 TwoPlus_lfa
         nv32forth.s:946    text:000006db TwoPlus
                             text:000006df TwoPlus_pfa
         nv32forth.s:3646   text:00001d52 Two
         nv32forth.s:955    text:000006eb OneMinus_nfa
         nv32forth.s:955    text:000006ee OneMinus_lfa
         nv32forth.s:955    text:000006f2 OneMinus
                             text:000006f6 OneMinus_pfa
         nv32forth.s:971    text:00000702 PlusMinus_nfa
         nv32forth.s:971    text:00000705 PlusMinus_lfa
         nv32forth.s:971    text:00000709 PlusMinus
                             text:0000070d PlusMinus_pfa
         nv32forth.s:976    text:0000071d PM1
         nv32forth.s:984    text:00000721 ABS_nfa
         nv32forth.s:984    text:00000725 ABS_lfa
         nv32forth.s:984    text:00000729 ABS
                             text:0000072d ABS_pfa
         nv32forth.s:1000   text:00000739 MIN_nfa
         nv32forth.s:1000   text:0000073d MIN_lfa
         nv32forth.s:1000   text:00000741 MIN
                             text:00000745 MIN_pfa
         nv32forth.s:1006   text:00000759 Min1
         nv32forth.s:1021   text:00000761 MAX_nfa
         nv32forth.s:1021   text:00000765 MAX_lfa
         nv32forth.s:1021   text:00000769 MAX
GAS LISTING nv32forth.s 			page 81


                             text:0000076d MAX_pfa
         nv32forth.s:1027   text:00000781 Max1
         nv32forth.s:1037   text:00000789 Star_nfa
         nv32forth.s:1037   text:0000078b Star_lfa
         nv32forth.s:1037   text:0000078f Star
                             text:00000793 Star_pfa
         nv32forth.s:1244   text:0000093c MStar
         nv32forth.s:1049   text:0000079f SlashMod_nfa
         nv32forth.s:1049   text:000007a4 SlashMod_lfa
         nv32forth.s:1049   text:000007a8 SlashMod
                             text:000007ac SlashMod_pfa
         nv32forth.s:1230   text:00000926 SignExtend
         nv32forth.s:1265   text:0000096f MSlash
         nv32forth.s:1062   text:000007c0 Slash_nfa
         nv32forth.s:1062   text:000007c2 Slash_lfa
         nv32forth.s:1062   text:000007c6 Slash
                             text:000007ca Slash_pfa
         nv32forth.s:1074   text:000007da MOD_nfa
         nv32forth.s:1074   text:000007de MOD_lfa
         nv32forth.s:1074   text:000007e2 MOD
                             text:000007e6 MOD_pfa
         nv32forth.s:1088   text:000007f2 StarSlashMod_nfa
         nv32forth.s:1088   text:000007f8 StarSlashMod_lfa
         nv32forth.s:1088   text:000007fc StarSlashMod
                             text:00000800 StarSlashMod_pfa
         nv32forth.s:1104   text:00000814 StarSlash_nfa
         nv32forth.s:1104   text:00000817 StarSlash_lfa
         nv32forth.s:1104   text:0000081b StarSlash
                             text:0000081f StarSlash_pfa
         nv32forth.s:1114   text:0000082f ShiftLeft_nfa
         nv32forth.s:1114   text:00000832 ShiftLeft_lfa
         nv32forth.s:1114   text:00000836 ShiftLeft
                             text:0000083a ShiftLeft_pfa
         nv32forth.s:1123   text:00000843 ShiftRight_nfa
         nv32forth.s:1123   text:00000846 ShiftRight_lfa
         nv32forth.s:1123   text:0000084a ShiftRight
                             text:0000084e ShiftRight_pfa
         nv32forth.s:1133   text:00000857 DPlus_nfa
         nv32forth.s:1133   text:0000085a DPlus_lfa
         nv32forth.s:1133   text:0000085e DPlus
                             text:00000862 DPlus_pfa
         nv32forth.s:1146   text:00000871 DSubtract_nfa
         nv32forth.s:1146   text:00000874 DSubtract_lfa
         nv32forth.s:1146   text:00000878 DSubtract
                             text:0000087c DSubtract_pfa
         nv32forth.s:1160   text:0000088b DMINUS_nfa
         nv32forth.s:1160   text:00000892 DMINUS_lfa
         nv32forth.s:1160   text:00000896 DMINUS
                             text:0000089a DMINUS_pfa
         nv32forth.s:1178   text:000008ab DPlusMinus_nfa
         nv32forth.s:1178   text:000008af DPlusMinus_lfa
         nv32forth.s:1178   text:000008b3 DPlusMinus
                             text:000008b7 DPlusMinus_pfa
         nv32forth.s:1183   text:000008c7 DPM1
         nv32forth.s:1192   text:000008cb DABS_nfa
         nv32forth.s:1192   text:000008d0 DABS_lfa
         nv32forth.s:1192   text:000008d4 DABS
GAS LISTING nv32forth.s 			page 82


                             text:000008d8 DABS_pfa
         nv32forth.s:1202   text:000008e4 UStar_nfa
         nv32forth.s:1202   text:000008e7 UStar_lfa
         nv32forth.s:1202   text:000008eb UStar
                             text:000008ef UStar_pfa
         nv32forth.s:1214   text:000008fc USlash_nfa
         nv32forth.s:1214   text:000008ff USlash_lfa
         nv32forth.s:1214   text:00000903 USlash
                             text:00000907 USlash_pfa
         nv32forth.s:1230   text:0000091d SignExtend_nfa
         nv32forth.s:1230   text:00000922 SignExtend_lfa
                             text:0000092a SignExtend_pfa
         nv32forth.s:1235   text:00000933 S2D1
         nv32forth.s:1244   text:00000935 MStar_nfa
         nv32forth.s:1244   text:00000938 MStar_lfa
                             text:00000940 MStar_pfa
         nv32forth.s:1265   text:00000968 MSlash_nfa
         nv32forth.s:1265   text:0000096b MSlash_lfa
                             text:00000973 MSlash_pfa
         nv32forth.s:1295   text:000009b3 MSlashMod_nfa
         nv32forth.s:1295   text:000009b9 MSlashMod_lfa
         nv32forth.s:1295   text:000009bd MSlashMod
                             text:000009c1 MSlashMod_pfa
         nv32forth.s:3644   text:00001d36 Zero
         nv32forth.s:1311   text:000009e9 Fetch_nfa
         nv32forth.s:1311   text:000009eb Fetch_lfa
         nv32forth.s:1311   text:000009ef Fetch
                             text:000009f3 Fetch_pfa
         nv32forth.s:1319   text:000009f9 CFetch_nfa
         nv32forth.s:1319   text:000009fc CFetch_lfa
         nv32forth.s:1319   text:00000a00 CFetch
                             text:00000a04 CFetch_pfa
         nv32forth.s:1329   text:00000a0a TFetch_nfa
         nv32forth.s:1329   text:00000a0d TFetch_lfa
         nv32forth.s:1329   text:00000a11 TFetch
                             text:00000a15 TFetch_pfa
         nv32forth.s:1341   text:00000a21 Store_nfa
         nv32forth.s:1341   text:00000a23 Store_lfa
                             text:00000a2b Store_pfa
         nv32forth.s:1352   text:00000a33 CStore_nfa
         nv32forth.s:1352   text:00000a36 CStore_lfa
         nv32forth.s:1352   text:00000a3a CStore
                             text:00000a3e CStore_pfa
         nv32forth.s:1361   text:00000a46 TStore_nfa
         nv32forth.s:1361   text:00000a49 TStore_lfa
         nv32forth.s:1361   text:00000a4d TStore
                             text:00000a51 TStore_pfa
         nv32forth.s:1372   text:00000a5a PlusPlus_nfa
         nv32forth.s:1372   text:00000a5d PlusPlus_lfa
         nv32forth.s:1372   text:00000a61 PlusPlus
                             text:00000a65 PlusPlus_pfa
         nv32forth.s:1384   text:00000a75 MinusMinus_nfa
         nv32forth.s:1384   text:00000a78 MinusMinus_lfa
         nv32forth.s:1384   text:00000a7c MinusMinus
                             text:00000a80 MinusMinus_pfa
         nv32forth.s:1398   text:00000a94 CVTWLFetch_nfa
         nv32forth.s:1398   text:00000a9b CVTWLFetch_lfa
GAS LISTING nv32forth.s 			page 83


         nv32forth.s:1398   text:00000a9f CVTWLFetch
                             text:00000aa3 CVTWLFetch_pfa
         nv32forth.s:1407   text:00000aa9 WStore_nfa
         nv32forth.s:1407   text:00000aac WStore_lfa
         nv32forth.s:1407   text:00000ab0 WStore
                             text:00000ab4 WStore_pfa
         nv32forth.s:1419   text:00000abc CMOVE_nfa
         nv32forth.s:1419   text:00000ac2 CMOVE_lfa
         nv32forth.s:1419   text:00000ac6 CMOVE
                             text:00000aca CMOVE_pfa
         nv32forth.s:1420   text:00000aca CMove1
         nv32forth.s:1437   text:00000add FILL_nfa
         nv32forth.s:1437   text:00000ae2 FILL_lfa
         nv32forth.s:1437   text:00000ae6 FILL
                             text:00000aea FILL_pfa
         nv32forth.s:1449   text:00000b01 FILL1
         nv32forth.s:1458   text:00000b06 ERASE_nfa
         nv32forth.s:1458   text:00000b0c ERASE_lfa
         nv32forth.s:1458   text:00000b10 ERASE
                             text:00000b14 ERASE_pfa
         nv32forth.s:1469   text:00000b20 BLANKS_nfa
         nv32forth.s:1469   text:00000b27 BLANKS_lfa
         nv32forth.s:1469   text:00000b2b BLANKS
                             text:00000b2f BLANKS_pfa
         nv32forth.s:3634   text:00001d18 BL
         nv32forth.s:1489   text:00000b4c ZBLIT_nfa
         nv32forth.s:1489   text:00000b52 ZBLIT_lfa
         nv32forth.s:1489   text:00000b56 ZBLIT
                             text:00000b5a ZBLIT_pfa
         nv32forth.s:1498   text:00000b5f OLIT_nfa
         nv32forth.s:1498   text:00000b64 OLIT_lfa
         nv32forth.s:1498   text:00000b68 OLIT
                             text:00000b6c OLIT_pfa
         nv32forth.s:3627   text:00001cb6 STATE
         nv32forth.s:1583   text:00000c14 Comma
         nv32forth.s:1540   text:00000ba2 DLITERAL_nfa
         nv32forth.s:1540   text:00000bab DLITERAL_lfa
         nv32forth.s:1540   text:00000baf DLITERAL
                             text:00000bb3 DLITERAL_pfa
         nv32forth.s:1548   text:00000bcf D1
         nv32forth.s:1555   text:00000bd3 HERE_nfa
         nv32forth.s:1555   text:00000bd8 HERE_lfa
                             text:00000be0 HERE_pfa
         nv32forth.s:3624   text:00001c81 DP
         nv32forth.s:1569   text:00000bec ALLOT_nfa
         nv32forth.s:1569   text:00000bf2 ALLOT_lfa
         nv32forth.s:1569   text:00000bf6 ALLOT
                             text:00000bfa ALLOT_pfa
         nv32forth.s:1583   text:00000c0e Comma_nfa
         nv32forth.s:1583   text:00000c10 Comma_lfa
                             text:00000c18 Comma_pfa
         nv32forth.s:1598   text:00000c30 WComma_nfa
         nv32forth.s:1598   text:00000c33 WComma_lfa
         nv32forth.s:1598   text:00000c37 WComma
                             text:00000c3b WComma_pfa
         nv32forth.s:1612   text:00000c4f CComma_nfa
         nv32forth.s:1612   text:00000c52 CComma_lfa
GAS LISTING nv32forth.s 			page 84


         nv32forth.s:1612   text:00000c56 CComma
                             text:00000c5a CComma_pfa
         nv32forth.s:1626   text:00000c6e OComma_nfa
         nv32forth.s:1626   text:00000c71 OComma_lfa
                             text:00000c79 OComma_pfa
         nv32forth.s:1637   text:00000c89 KEY_nfa
         nv32forth.s:1637   text:00000c8d KEY_lfa
         nv32forth.s:1637   text:00000c91 KEY
                             text:00000c95 KEY_pfa
         nv32forth.s:1648   text:00000c9d QKey_nfa
         nv32forth.s:1648   text:00000ca2 QKey_lfa
         nv32forth.s:1648   text:00000ca6 QKey
                             text:00000caa QKey_pfa
         nv32forth.s:1659   text:00000cb2 EMIT_nfa
         nv32forth.s:1659   text:00000cb7 EMIT_lfa
         nv32forth.s:1659   text:00000cbb EMIT
                             text:00000cbf EMIT_pfa
         nv32forth.s:1674   text:00000cca FConOut
         nv32forth.s:1665   text:00000cc9 invis
         nv32forth.s:1678   text:00000cd2 fconout1
         nv32forth.s:1689   text:00000cd3 DotOff_nfa
         nv32forth.s:1689   text:00000cd8 DotOff_lfa
         nv32forth.s:1689   text:00000cdc DotOff
                             text:00000ce0 DotOff_pfa
         nv32forth.s:1700   text:00000ce5 DotOn_nfa
         nv32forth.s:1700   text:00000ce9 DotOn_lfa
         nv32forth.s:1700   text:00000ced DotOn
                             text:00000cf1 DotOn_pfa
         nv32forth.s:1712   text:00000cf7 QTerminal_nfa
         nv32forth.s:1712   text:00000d01 QTerminal_lfa
         nv32forth.s:1712   text:00000d05 QTerminal
                             text:00000d09 QTerminal_pfa
         nv32forth.s:1725   text:00000d0d CR_nfa
         nv32forth.s:1725   text:00000d10 CR_lfa
         nv32forth.s:1725   text:00000d14 CR
                             text:00000d18 CR_pfa
         nv32forth.s:1737   text:00000d34 SPACE_nfa
         nv32forth.s:1737   text:00000d3a SPACE_lfa
         nv32forth.s:1737   text:00000d3e SPACE
                             text:00000d42 SPACE_pfa
         nv32forth.s:1748   text:00000d4e HEX_nfa
         nv32forth.s:1748   text:00000d52 HEX_lfa
         nv32forth.s:1748   text:00000d56 HEX
                             text:00000d5a HEX_pfa
         nv32forth.s:3628   text:00001cc7 BASE
         nv32forth.s:1760   text:00000d6e DECIMAL_nfa
         nv32forth.s:1760   text:00000d76 DECIMAL_lfa
         nv32forth.s:1760   text:00000d7a DECIMAL
                             text:00000d7e DECIMAL_pfa
         nv32forth.s:1774   text:00000d92 DIGIT_nfa
         nv32forth.s:1774   text:00000d98 DIGIT_lfa
         nv32forth.s:1774   text:00000d9c DIGIT
                             text:00000da0 DIGIT_pfa
         nv32forth.s:1802   text:00000dda Digit_Nope
         nv32forth.s:1786   text:00000db5 Digit_Alpha
         nv32forth.s:1794   text:00000dcd Digit_Test
         nv32forth.s:1813   text:00000dde TYPE_nfa
GAS LISTING nv32forth.s 			page 85


         nv32forth.s:1813   text:00000de3 TYPE_lfa
         nv32forth.s:1813   text:00000de7 TYPE
                             text:00000deb TYPE_pfa
         nv32forth.s:1816   text:00000df1 Type1
         nv32forth.s:1829   text:00000dfc COUNT_nfa
         nv32forth.s:1829   text:00000e02 COUNT_lfa
         nv32forth.s:1829   text:00000e06 COUNT
                             text:00000e0a COUNT_pfa
         nv32forth.s:1842   text:00000e13 PDotQuote_nfa
         nv32forth.s:1842   text:00000e18 PDotQuote_lfa
         nv32forth.s:1842   text:00000e1c PDotQuote
                             text:00000e20 PDotQuote_pfa
         nv32forth.s:1875   text:00000e44 DotQuote_nfa
         nv32forth.s:1875   text:00000e47 DotQuote_lfa
         nv32forth.s:1875   text:00000e4b DotQuote
                             text:00000e4f DotQuote_pfa
         nv32forth.s:1890   text:00000e8b Quote1
         nv32forth.s:3042   text:000017a4 WORD
         nv32forth.s:1894   text:00000e9b Quote2
         nv32forth.s:1918   text:00000e9f QUERY_nfa
         nv32forth.s:1918   text:00000ea5 QUERY_lfa
         nv32forth.s:1918   text:00000ea9 QUERY
                             text:00000ead QUERY_pfa
         nv32forth.s:3622   text:00001c62 PTib
         nv32forth.s:3665   text:00001d90 BDOS
         nv32forth.s:3623   text:00001c72 TIB
         nv32forth.s:3625   text:00001c90 IN
         nv32forth.s:1959   text:00000efd ENCLOSE_nfa
         nv32forth.s:1959   text:00000f05 ENCLOSE_lfa
         nv32forth.s:1959   text:00000f09 ENCLOSE
                             text:00000f0d ENCLOSE_pfa
         nv32forth.s:1968   text:00000f1b encl1
         nv32forth.s:1982   text:00000f34 encl2
         nv32forth.s:1995   text:00000f49 encl4
         nv32forth.s:2008   text:00000f52 HOLD_nfa
         nv32forth.s:2008   text:00000f57 HOLD_lfa
         nv32forth.s:2008   text:00000f5b HOLD
                             text:00000f5f HOLD_pfa
         nv32forth.s:3631   text:00001cf7 HLD
         nv32forth.s:2048   text:00000f77 PNumber_nfa
         nv32forth.s:2048   text:00000f80 PNumber_lfa
         nv32forth.s:2048   text:00000f84 PNumber
                             text:00000f88 PNumber_pfa
         nv32forth.s:2049   text:00000f88 Num1
         nv32forth.s:2078   text:00000ffc Num2
         nv32forth.s:3629   text:00001cd7 DPL
         nv32forth.s:2075   text:00000ff0 Num3
         nv32forth.s:2114   text:00001004 NUMBER_nfa
         nv32forth.s:2114   text:0000100b NUMBER_lfa
         nv32forth.s:2114   text:0000100f NUMBER
                             text:00001013 NUMBER_pfa
         nv32forth.s:2127   text:0000104b N1
         nv32forth.s:2145   text:00001097 N2
         nv32forth.s:3182   text:000018d8 QError
         nv32forth.s:2150   text:000010ab N3
         nv32forth.s:2163   text:000010af SPACES_nfa
         nv32forth.s:2163   text:000010b6 SPACES_lfa
GAS LISTING nv32forth.s 			page 86


         nv32forth.s:2163   text:000010ba SPACES
                             text:000010be SPACES_pfa
         nv32forth.s:2174   text:000010e6 Spaces1
         nv32forth.s:2171   text:000010da Spaces2
         nv32forth.s:3636   text:00001d28 PAD
         nv32forth.s:2201   text:00001105 HashGreater_nfa
         nv32forth.s:2201   text:00001108 HashGreater_lfa
         nv32forth.s:2201   text:0000110c HashGreater
                             text:00001110 HashGreater_pfa
         nv32forth.s:2221   text:00001130 SIGN_nfa
         nv32forth.s:2221   text:00001135 SIGN_lfa
         nv32forth.s:2221   text:00001139 SIGN
                             text:0000113d SIGN_pfa
         nv32forth.s:2228   text:00001159 Sign1
         nv32forth.s:2248   text:0000115d Hash_nfa
         nv32forth.s:2248   text:0000115f Hash_lfa
         nv32forth.s:2248   text:00001163 Hash
                             text:00001167 Hash_pfa
         nv32forth.s:2260   text:0000119b Hash1
         nv32forth.s:2273   text:000011af HashS_nfa
         nv32forth.s:2273   text:000011b2 HashS_lfa
         nv32forth.s:2273   text:000011b6 HashS
                             text:000011ba HashS_pfa
         nv32forth.s:2274   text:000011ba HashS1
         nv32forth.s:2295   text:000011d6 DDotR_nfa
         nv32forth.s:2295   text:000011da DDotR_lfa
         nv32forth.s:2295   text:000011de DDotR
                             text:000011e2 DDotR_pfa
         nv32forth.s:2319   text:0000121a DotR_nfa
         nv32forth.s:2319   text:0000121d DotR_lfa
         nv32forth.s:2319   text:00001221 DotR
                             text:00001225 DotR_pfa
         nv32forth.s:2332   text:00001239 DDot_nfa
         nv32forth.s:2332   text:0000123c DDot_lfa
         nv32forth.s:2332   text:00001240 DDot
                             text:00001244 DDot_pfa
         nv32forth.s:2346   text:00001254 Dot_nfa
         nv32forth.s:2346   text:00001256 Dot_lfa
         nv32forth.s:2346   text:0000125a Dot
                             text:0000125e Dot_pfa
         nv32forth.s:2358   text:0000126a Question_nfa
         nv32forth.s:2358   text:0000126c Question_lfa
         nv32forth.s:2358   text:00001270 Question
                             text:00001274 Question_pfa
         nv32forth.s:2371   text:00001280 UDot_nfa
         nv32forth.s:2371   text:00001283 UDot_lfa
         nv32forth.s:2371   text:00001287 UDot
                             text:0000128b UDot_pfa
         nv32forth.s:2394   text:00001297 EXPECT_nfa
         nv32forth.s:2394   text:0000129e EXPECT_lfa
         nv32forth.s:2394   text:000012a2 EXPECT
                             text:000012a6 EXPECT_pfa
         nv32forth.s:2400   text:000012b2 Expect1
         nv32forth.s:2438   text:000012f6 Expect_CR
         nv32forth.s:2424   text:000012db Expect_BS
         nv32forth.s:2446   text:00001309 Expect_Exit
         nv32forth.s:2465   text:0000130b IDDot_nfa
GAS LISTING nv32forth.s 			page 87


         nv32forth.s:2465   text:0000130f IDDot_lfa
         nv32forth.s:2465   text:00001313 IDDot
                             text:00001317 IDDot_pfa
         nv32forth.s:2486   text:00001343 SemiS_nfa
         nv32forth.s:2486   text:00001346 SemiS_lfa
                             text:0000134e SemiS_pfa
         nv32forth.s:2508   text:0000136d RBracket_nfa
         nv32forth.s:2508   text:0000136f RBracket_lfa
         nv32forth.s:2508   text:00001373 RBracket
                             text:00001377 RBracket_pfa
         nv32forth.s:2530   text:0000138b Colon_nfa
         nv32forth.s:2530   text:0000138d Colon_lfa
         nv32forth.s:2530   text:00001391 Colon
                             text:00001395 Colon_pfa
         nv32forth.s:3216   text:00001928 QExec
         nv32forth.s:2855   text:000015f8 CREATE
         nv32forth.s:2663   text:00001483 PSemiCode
         nv32forth.s:2550   text:000013b1 Semicolon_nfa
         nv32forth.s:2550   text:000013b3 Semicolon_lfa
         nv32forth.s:2550   text:000013b7 Semicolon
                             text:000013bb Semicolon_pfa
         nv32forth.s:3249   text:00001970 QCSP
         nv32forth.s:2814   text:000015ba SMUDGE
         nv32forth.s:2572   text:000013d3 CONSTANT_nfa
         nv32forth.s:2572   text:000013dc CONSTANT_lfa
         nv32forth.s:2572   text:000013e0 CONSTANT
                             text:000013e4 CONSTANT_pfa
         nv32forth.s:2595   text:000013fc VARIABLE_nfa
         nv32forth.s:2595   text:00001405 VARIABLE_lfa
         nv32forth.s:2595   text:00001409 VARIABLE
                             text:0000140d VARIABLE_pfa
         nv32forth.s:2613   text:0000141d CODE_nfa
         nv32forth.s:2613   text:00001422 CODE_lfa
         nv32forth.s:2613   text:00001426 CODE
                             text:0000142a CODE_pfa
         nv32forth.s:2638   text:0000144e EDOC_nfa
         nv32forth.s:2638   text:00001453 EDOC_lfa
         nv32forth.s:2638   text:00001457 EDOC
                             text:0000145b EDOC_pfa
         nv32forth.s:2663   text:00001477 PSemiCode_nfa
         nv32forth.s:2663   text:0000147f PSemiCode_lfa
                             text:00001487 PSemiCode_pfa
         nv32forth.s:2792   text:00001583 PFA
         nv32forth.s:2751   text:00001533 CFA
         nv32forth.s:2705   text:000014cf MinusFind_nfa
         nv32forth.s:2705   text:000014d5 MinusFind_lfa
         nv32forth.s:2705   text:000014d9 MinusFind
                             text:000014dd MinusFind_pfa
         nv32forth.s:3084   text:00001830 PFind
         nv32forth.s:2722   text:000014f5 Comment_nfa
         nv32forth.s:2722   text:000014f7 Comment_lfa
         nv32forth.s:2722   text:000014fb Comment
                             text:000014ff Comment_pfa
         nv32forth.s:2751   text:0000152b CFA_nfa
         nv32forth.s:2751   text:0000152f CFA_lfa
                             text:00001537 CFA_pfa
         nv32forth.s:2771   text:00001547 NFA_nfa
GAS LISTING nv32forth.s 			page 88


         nv32forth.s:2771   text:0000154b NFA_lfa
         nv32forth.s:2771   text:0000154f NFA
                             text:00001553 NFA_pfa
         nv32forth.s:2773   text:00001557 NFA1
         nv32forth.s:2792   text:0000157b PFA_nfa
         nv32forth.s:2792   text:0000157f PFA_lfa
                             text:00001587 PFA_pfa
         nv32forth.s:2814   text:000015af SMUDGE_nfa
         nv32forth.s:2814   text:000015b6 SMUDGE_lfa
                             text:000015be SMUDGE_pfa
         nv32forth.s:3626   text:00001ca4 CURRENT
         nv32forth.s:2855   text:000015ed CREATE_nfa
         nv32forth.s:2855   text:000015f4 CREATE_lfa
                             text:000015fc CREATE_pfa
         nv32forth.s:2891   text:00001650 COMPILE_nfa
         nv32forth.s:2891   text:00001658 COMPILE_lfa
                             text:00001660 COMPILE_pfa
         nv32forth.s:2912   text:0000168c BracketsCOMPILE_nfa
         nv32forth.s:2912   text:00001696 BracketsCOMPILE_lfa
         nv32forth.s:2912   text:0000169a BracketsCOMPILE
                             text:0000169e BracketsCOMPILE_pfa
         nv32forth.s:2931   text:000016be IMMEDIATE_nfa
         nv32forth.s:2931   text:000016c8 IMMEDIATE_lfa
         nv32forth.s:2931   text:000016cc IMMEDIATE
                             text:000016d0 IMMEDIATE_pfa
         nv32forth.s:2955   text:000016e4 FORGET_nfa
         nv32forth.s:2955   text:000016eb FORGET_lfa
         nv32forth.s:2955   text:000016ef FORGET
                             text:000016f3 FORGET_pfa
         nv32forth.s:3014   text:0000177b Tick
         nv32forth.s:2987   text:00001727 VLIST_nfa
         nv32forth.s:2987   text:0000172d VLIST_lfa
         nv32forth.s:2987   text:00001731 VLIST
                             text:00001735 VLIST_pfa
         nv32forth.s:2989   text:00001739 vlist1
         nv32forth.s:3001   text:00001769 vlist2
         nv32forth.s:3014   text:00001775 Tick_nfa
         nv32forth.s:3014   text:00001777 Tick_lfa
                             text:0000177f Tick_pfa
         nv32forth.s:3042   text:0000179b WORD_nfa
         nv32forth.s:3042   text:000017a0 WORD_lfa
                             text:000017a8 WORD_pfa
         nv32forth.s:3074   text:0000180c EXECUTE_nfa
         nv32forth.s:3074   text:00001814 EXECUTE_lfa
         nv32forth.s:3074   text:00001818 EXECUTE
                             text:0000181c EXECUTE_pfa
         nv32forth.s:3084   text:00001825 PFind_nfa
         nv32forth.s:3084   text:0000182c PFind_lfa
                             text:00001834 PFind_pfa
         nv32forth.s:3090   text:00001834 PFind1
         nv32forth.s:3126   text:00001875 PFind2
         nv32forth.s:3140   text:00001890 PFind3
         nv32forth.s:3161   text:00001896 ERROR_nfa
         nv32forth.s:3161   text:0000189c ERROR_lfa
         nv32forth.s:3161   text:000018a0 ERROR
                             text:000018a4 ERROR_pfa
         nv32forth.s:3434   text:00001b14 QUIT
GAS LISTING nv32forth.s 			page 89


         nv32forth.s:3182   text:000018cd QError_nfa
         nv32forth.s:3182   text:000018d4 QError_lfa
                             text:000018dc QError_pfa
         nv32forth.s:3187   text:000018ec QErr1
         nv32forth.s:3201   text:000018f4 QComp_nfa
         nv32forth.s:3201   text:000018fa QComp_lfa
         nv32forth.s:3201   text:000018fe QComp
                             text:00001902 QComp_pfa
         nv32forth.s:3216   text:0000191e QExec_nfa
         nv32forth.s:3216   text:00001924 QExec_lfa
                             text:0000192c QExec_pfa
         nv32forth.s:3235   text:00001944 QPairs_nfa
         nv32forth.s:3235   text:0000194b QPairs_lfa
                             text:00001953 QPairs_pfa
         nv32forth.s:3249   text:00001967 QCSP_nfa
         nv32forth.s:3249   text:0000196c QCSP_lfa
                             text:00001974 QCSP_pfa
         nv32forth.s:3263   text:00001994 QStack_nfa
         nv32forth.s:3263   text:0000199b QStack_lfa
         nv32forth.s:3263   text:0000199f QStack
                             text:000019a3 QStack_pfa
         nv32forth.s:3274   text:000019a7 IF_nfa
         nv32forth.s:3274   text:000019aa IF_lfa
         nv32forth.s:3274   text:000019ae IF
                             text:000019b2 IF_pfa
         nv32forth.s:3296   text:000019ce ELSE_nfa
         nv32forth.s:3296   text:000019d3 ELSE_lfa
         nv32forth.s:3296   text:000019d7 ELSE
                             text:000019db ELSE_pfa
         nv32forth.s:3319   text:00001a14 THEN
         nv32forth.s:3319   text:00001a0b THEN_nfa
         nv32forth.s:3319   text:00001a10 THEN_lfa
                             text:00001a18 THEN_pfa
         nv32forth.s:3337   text:00001a3c BEGIN_nfa
         nv32forth.s:3337   text:00001a42 BEGIN_lfa
         nv32forth.s:3337   text:00001a46 BEGIN
                             text:00001a4a BEGIN_pfa
         nv32forth.s:3353   text:00001a5a UNTIL_nfa
         nv32forth.s:3353   text:00001a60 UNTIL_lfa
         nv32forth.s:3353   text:00001a64 UNTIL
                             text:00001a68 UNTIL_pfa
         nv32forth.s:3370   text:00001a80 AGAIN_nfa
         nv32forth.s:3370   text:00001a86 AGAIN_lfa
         nv32forth.s:3370   text:00001a8a AGAIN
                             text:00001a8e AGAIN_pfa
         nv32forth.s:3388   text:00001aaa REPEAT_nfa
         nv32forth.s:3388   text:00001ab1 REPEAT_lfa
         nv32forth.s:3388   text:00001ab5 REPEAT
                             text:00001ab9 REPEAT_pfa
         nv32forth.s:3407   text:00001ae1 WHILE_nfa
         nv32forth.s:3407   text:00001ae7 WHILE_lfa
         nv32forth.s:3407   text:00001aeb WHILE
                             text:00001aef WHILE_pfa
         nv32forth.s:3416   text:00001afb NOP_nfa
         nv32forth.s:3416   text:00001aff NOP_lfa
         nv32forth.s:3416   text:00001b03 NOP
                             text:00001b07 NOP_pfa
GAS LISTING nv32forth.s 			page 90


         nv32forth.s:3434   text:00001b0b QUIT_nfa
         nv32forth.s:3434   text:00001b10 QUIT_lfa
                             text:00001b18 QUIT_pfa
         nv32forth.s:3436   text:00001b1c Q1
         nv32forth.s:3564   text:00001bb7 INTERPRET
         nv32forth.s:3447   text:00001b47 Q2
         nv32forth.s:3465   text:00001b53 ABORT_nfa
         nv32forth.s:3465   text:00001b59 ABORT_lfa
         nv32forth.s:3465   text:00001b5d ABORT
                             text:00001b61 ABORT_pfa
         nv32forth.s:3481   text:00001b8a DotCPU
         nv32forth.s:3481   text:00001b81 DotCPU_nfa
         nv32forth.s:3481   text:00001b86 DotCPU_lfa
                             text:00001b8e DotCPU_pfa
         nv32forth.s:3564   text:00001ba9 INTERPRET_nfa
         nv32forth.s:3564   text:00001bb3 INTERPRET_lfa
                             text:00001bbb INTERPRET_pfa
         nv32forth.s:3565   text:00001bbb I1
         nv32forth.s:3582   text:00001bff I2
         nv32forth.s:3577   text:00001beb I3
         nv32forth.s:3579   text:00001bf3 I4
         nv32forth.s:3595   text:00001c33 I5
         nv32forth.s:3592   text:00001c27 I6
         nv32forth.s:3594   text:00001c2f I7
         nv32forth.s:3606   text:00001c3f EXIT_nfa
         nv32forth.s:3606   text:00001c44 EXIT_lfa
         nv32forth.s:3606   text:00001c48 EXIT
                             text:00001c4c EXIT_pfa
         nv32forth.s:3622   text:00001c58 PTib_nfa
         nv32forth.s:3622   text:00001c5e PTib_lfa
                             text:00001c66 PTib_pfa
         nv32forth.s:3623   text:00001c6a TIB_nfa
         nv32forth.s:3623   text:00001c6e TIB_lfa
                             text:00001c76 TIB_pfa
         nv32forth.s:3624   text:00001c7a DP_nfa
         nv32forth.s:3624   text:00001c7d DP_lfa
                             text:00001c85 DP_pfa
         nv32forth.s:3625   text:00001c89 IN_nfa
         nv32forth.s:3625   text:00001c8c IN_lfa
                             text:00001c94 IN_pfa
         nv32forth.s:3626   text:00001c98 CURRENT_nfa
         nv32forth.s:3626   text:00001ca0 CURRENT_lfa
                             text:00001ca8 CURRENT_pfa
         nv32forth.s:3627   text:00001cac STATE_nfa
         nv32forth.s:3627   text:00001cb2 STATE_lfa
                             text:00001cba STATE_pfa
         nv32forth.s:3628   text:00001cbe BASE_nfa
         nv32forth.s:3628   text:00001cc3 BASE_lfa
                             text:00001ccb BASE_pfa
         nv32forth.s:3629   text:00001ccf DPL_nfa
         nv32forth.s:3629   text:00001cd3 DPL_lfa
                             text:00001cdb DPL_pfa
         nv32forth.s:3630   text:00001cdf CSP_nfa
         nv32forth.s:3630   text:00001ce3 CSP_lfa
                             text:00001ceb CSP_pfa
         nv32forth.s:3631   text:00001cef HLD_nfa
         nv32forth.s:3631   text:00001cf3 HLD_lfa
GAS LISTING nv32forth.s 			page 91


                             text:00001cfb HLD_pfa
         nv32forth.s:3632   text:00001cff BSlashBuf_nfa
         nv32forth.s:3632   text:00001d05 BSlashBuf_lfa
         nv32forth.s:3632   text:00001d09 BSlashBuf
                             text:00001d0d BSlashBuf_pfa
         nv32forth.s:3634   text:00001d11 BL_nfa
         nv32forth.s:3634   text:00001d14 BL_lfa
                             text:00001d1c BL_pfa
         nv32forth.s:3636   text:00001d20 PAD_nfa
         nv32forth.s:3636   text:00001d24 PAD_lfa
                             text:00001d2c PAD_pfa
         nv32forth.s:3644   text:00001d30 Zero_nfa
         nv32forth.s:3644   text:00001d32 Zero_lfa
                             text:00001d3a Zero_pfa
         nv32forth.s:3645   text:00001d3e One_nfa
         nv32forth.s:3645   text:00001d40 One_lfa
                             text:00001d48 One_pfa
         nv32forth.s:3646   text:00001d4c Two_nfa
         nv32forth.s:3646   text:00001d4e Two_lfa
                             text:00001d56 Two_pfa
         nv32forth.s:3648   text:00001d5a HALT_nfa
         nv32forth.s:3648   text:00001d5f HALT_lfa
         nv32forth.s:3648   text:00001d63 HALT
                             text:00001d67 HALT_pfa
         nv32forth.s:3656   text:00001d6a BASEPAGE_nfa
         nv32forth.s:3656   text:00001d73 BASEPAGE_lfa
         nv32forth.s:3656   text:00001d77 BASEPAGE
                             text:00001d7b BASEPAGE_pfa
         nv32forth.s:3665   text:00001d87 BDOS_nfa
         nv32forth.s:3665   text:00001d8c BDOS_lfa
                             text:00001d94 BDOS_pfa
         nv32forth.s:3674   text:00001da8 Forth$$LastWord_NFA
         nv32forth.s:3676   text:00001da8 COLD_nfa
         nv32forth.s:3676   text:00001dad COLD_lfa
         nv32forth.s:3676   text:00001db1 COLD
                             text:00001db5 COLD_pfa
         nv32forth.s:3700   text:00001e08 DictEnd

NO UNDEFINED SYMBOLS
